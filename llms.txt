This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
examples/
  knitpy_overview.html
  knitpy_overview.html_document.md
  knitpy_overview.pymd
pymdknit/
  tests/
    basics/
      blocks.md
      blocks.pymd
      errors.md
      errors.pymd
      inlinecode.md
      inlinecode.pymd
      invalid_code.md
      invalid_code.md_py3
      invalid_code.pymd
      loops.md
      loops.pymd
    chunk_options/
      comment.md
      comment.pymd
      echo.md
      echo.pymd
      eval.md
      eval.pymd
      include.md
      include.pymd
      r_style_options.md
      r_style_options.pymd
      results.md
      results.pymd
    __init__.py
    test_conversion.py
  __init__.py
  documents.py
  encoding.py
  engines.py
  path.py
  py3compat.py
  pymdknit.py
  pymdknitapp.py
  utils.py
.gitignore
.travis.yml
conda_env_dev_27.yml
conda_env_dev_35.yml
LICENSE.rst
pymdknit.py
README.md
setup.py
test_singleconversion.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="pymdknit/tests/basics/blocks.md">
# A minimal code chunks example

A _paragraph_ here. A code chunk below (remember the three backticks):

```python
1+1
```

```
## 2
```

```python
.4-.7+.3 # what? it is not zero!
```

```
## 5.551115123125783e-17
```
</file>

<file path="pymdknit/tests/basics/blocks.pymd">
# A minimal code chunks example

A _paragraph_ here. A code chunk below (remember the three backticks):

```{python}
1+1
.4-.7+.3 # what? it is not zero!
```
</file>

<file path="pymdknit/tests/basics/errors.md">
# Errors in code

```python
import NoneExistingModule
```

**ERROR**: ImportError: No module named NoneExistingModule

```
ImportError                               Traceback (most recent call last)
<ipython-input> in <module>()
----> 1 import NoneExistingModule

ImportError: No module named NoneExistingModule
```


```python
raise Exception("Message should be shown...")
```

**ERROR**: Exception: Message should be shown...

```
Exception                                 Traceback (most recent call last)
<ipython-input> in <module>()
----> 1 raise Exception("Message should be shown...")

Exception: Message should be shown...
```


# And both together in one block

```python
import NoneExistingModule
```

**ERROR**: ImportError: No module named NoneExistingModule

```
ImportError                               Traceback (most recent call last)
<ipython-input> in <module>()
----> 1 import NoneExistingModule

ImportError: No module named NoneExistingModule
```

```python
raise Exception("Message should be shown...")
```

**ERROR**: Exception: Message should be shown...

```
Exception                                 Traceback (most recent call last)
<ipython-input> in <module>()
----> 1 raise Exception("Message should be shown...")

Exception: Message should be shown...
```
</file>

<file path="pymdknit/tests/basics/errors.pymd">
# Errors in code

```{python}
import NoneExistingModule
```

```{python}
raise Exception("Message should be shown...")
```

# And both together in one block

```{python}
import NoneExistingModule
raise Exception("Message should be shown...")
```
</file>

<file path="pymdknit/tests/basics/inlinecode.md">
# A minimal inline example

We can do math: `1+1=2`. Yay, we are happy!

Yes I know the value of pi is 3.141592653589793, and 2 times pi is 6.283185307179586.
</file>

<file path="pymdknit/tests/basics/inlinecode.pymd">
# A minimal inline example

We can do math: `1+1=`python 1+1``. Yay, we are happy!

Yes I know the value of pi is `python import math; math.pi`, and 2 times pi is `python 2*math.pi`.
</file>

<file path="pymdknit/tests/basics/invalid_code.md">
# Invalid Code

```python
"text without a closing quote...
```

**ERROR**: Code invalid


```python
"text without a closing quote...
```

**ERROR**: Code invalid

```python
"More text without a closing quote...
```

**ERROR**: Code invalid


```python
s = ""
# after
   # after2
   print(test)
```

**ERROR**: Code invalid


```python
for i in range(x):

```

**ERROR**: IndentationError: expected an indented block (<ipython-input>, line 2)


```python
for i in range(x):
print(i)
```

**ERROR**: Code invalid
</file>

<file path="pymdknit/tests/basics/invalid_code.md_py3">
# Invalid Code

```python
"text without a closing quote...
```

**ERROR**: Code invalid


```python
"text without a closing quote...
```

**ERROR**: Code invalid

```python
"More text without a closing quote...
```

**ERROR**: Code invalid


```python
s = ""
# after
   # after2
   print(test)
```

**ERROR**: Code invalid


```python
for i in range(x):

```

**ERROR**: SyntaxError: unexpected EOF while parsing (<ipython-input>, line 2)


```python
for i in range(x):
print(i)
```

**ERROR**: Code invalid
</file>

<file path="pymdknit/tests/basics/invalid_code.pymd">
# Invalid Code

```{python}
"text without a closing quote...
```

```{python}
"text without a closing quote...
"More text without a closing quote...
```

```{python}
s = ""
# after
   # after2
   print(test)
```

```{python}
for i in range(x):
```

```{python}
for i in range(x):
print(i)
```
</file>

<file path="pymdknit/tests/basics/loops.md">
# Loops

Problem here is that the loop + the first line is usually enough to make something valid code

```python
s = ""
for i in range(10):
    s += " %s" %i
s
```

```
## ' 0 1 2 3 4 5 6 7 8 9'
```

```python
s = ""
for i in range(10):
    j = i
    s += " %s" %j
s
```

```
## ' 0 1 2 3 4 5 6 7 8 9'
```

```python
s = ""
for i in range(10):
   # test
    j = i
    # test
# test
    # test
    s += " %s" %j
s
```

```
## ' 0 1 2 3 4 5 6 7 8 9'
```

```python
s = ""
for i in range(10):
    for j in range(i):
        s += " %s" %j
s
```

```
## ' 0 0 1 0 1 2 0 1 2 3 0 1 2 3 4 0 1 2 3 4 5 0 1 2 3 4 5 6 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 8'
```

```python
s = ""
for i in range(10):
    for j in range(i):
        k = j
        s += " %s" %k
s
```

```
## ' 0 0 1 0 1 2 0 1 2 3 0 1 2 3 4 0 1 2 3 4 5 0 1 2 3 4 5 6 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 8'
```

```python
s = ""
for i in range(10):
    for j in range(i):
        k = j
        s += " %s" %k
    s += " loop"
s
```

```
## ' loop 0 loop 0 1 loop 0 1 2 loop 0 1 2 3 loop 0 1 2 3 4 loop 0 1 2 3 4 5 loop 0 1 2 3 4 5 6 loop 0 1 2 3 4 5 6 7 loop 0 1 2 3 4 5 6 7 8 loop'
```

```python
 # test
for i in range(3):
    # test
      #test
    print(i)
# text
    print("works")
```

```
## 0
## works
## 1
## works
## 2
## works
```
</file>

<file path="pymdknit/tests/basics/loops.pymd">
# Loops

Problem here is that the loop + the first line is usually enough to make something valid code

```{python}
s = ""
for i in range(10):
    s += " %s" %i
s
```

```{python}
s = ""
for i in range(10):
    j = i
    s += " %s" %j
s
```

```{python}
s = ""
for i in range(10):
   # test
    j = i
    # test
# test
    # test
    s += " %s" %j
s
```


```{python}
s = ""
for i in range(10):
    for j in range(i):
        s += " %s" %j
s
```

```{python}
s = ""
for i in range(10):
    for j in range(i):
        k = j
        s += " %s" %k
s
```

```{python}
s = ""
for i in range(10):
    for j in range(i):
        k = j
        s += " %s" %k
    s += " loop"
s
```


```{python}
 # test
for i in range(3):
    # test
      #test
    print(i)
# text
    print("works")
```
</file>

<file path="pymdknit/tests/chunk_options/comment.md">
# comment code chunk option

## the default is two comments

```python
1+1
```

```
## 2
```

## change it to only one comment

```python
1+1
```

```
# 2
```

## The following two outputs should have no comments

```python
1+1
```

```
2
```

```python
1+1
```

```
2
```
</file>

<file path="pymdknit/tests/chunk_options/comment.pymd">
# comment code chunk option

## the default is two comments

```{python}
1+1
```

## change it to only one comment

```{python comment="#"}
1+1
```

## The following two outputs should have no comments

```{python comment=""}
1+1
```

```{python comment=None}
1+1
```
</file>

<file path="pymdknit/tests/chunk_options/echo.md">
# echo code chunk option

```
## code not shown above and this is in one block
## 2
```

```python
print("code shown above and in multiple blocks")
```

```
## code shown above and in multiple blocks
```

```python
1+1
```

```
## 2
```
</file>

<file path="pymdknit/tests/chunk_options/echo.pymd">
# echo code chunk option

```{python echo=False}
print("code not shown above and this is in one block")
1+1
```

```{python echo=True}
print("code shown above and in multiple blocks")
1+1
```
</file>

<file path="pymdknit/tests/chunk_options/eval.md">
# eval code chunk option

```python
res = 1
```

```python
# This code is shown, but no output and the code is not executed!
res += 1
res
```

```python
# Both input code and output is shown
res += 1
res # is now 2
```

```
## 2
```

No output between here...



...and here

```
## 2
```
</file>

<file path="pymdknit/tests/chunk_options/eval.pymd">
# eval code chunk option

```{python}
res = 1
```

```{python eval=False}
# This code is shown, but no output and the code is not executed!
res += 1
res
```

```{python eval=True}
# Both input code and output is shown
res += 1
res # is now 2
```

No output between here...

```{python eval=False, echo=False}
# Neither the code nor the output is shown
res += 1
res
```

```{python eval=False, include=False}
# Again, neither the code nor the output is shown
res += 1
res
```

...and here

```{python}
res # should still be 2

```
</file>

<file path="pymdknit/tests/chunk_options/include.md">
# include code chunk options

Here we have two empty lines, because the ones from markdown are preserved...


```python
if have_run == True:
    print("'have_run==True': ran the codeblock before this one.")
```

```
## 'have_run==True': ran the codeblock before this one.
```
</file>

<file path="pymdknit/tests/chunk_options/include.pymd">
# include code chunk options

Here we have two empty lines, because the ones from markdown are preserved...

```{python include=False}
have_run = True
print("## This will show as a real headline")
```

```{python include=True}
if have_run == True:
    print("'have_run==True': ran the codeblock before this one.")
```
</file>

<file path="pymdknit/tests/chunk_options/r_style_options.md">
# r style code chunk option evaluation

```
## No code shown above
```

```
## No code shown above
```

And now the code is shown...

```python
1+1
```

```
## 2
```

```python
1+1
```

```
## 2
```
</file>

<file path="pymdknit/tests/chunk_options/r_style_options.pymd">
# r style code chunk option evaluation

```{python echo=FALSE}
print("No code shown above")
```

```{python echo=F}
print("No code shown above")
```

And now the code is shown...

```{python echo=TRUE}
1+1
```

```{python echo=T}
1+1
```
</file>

<file path="pymdknit/tests/chunk_options/results.md">
# results code chunk option

```python
# results are hidden
1+1
```

```python
1+1
```

```
## 2
```

```python
print("**This text** will be bold...")
```

**This text** will be bold...
</file>

<file path="pymdknit/tests/chunk_options/results.pymd">
# results code chunk option

```{python results="hide"}
# results are hidden
1+1
```

```{python results="markup"}
1+1
```

```{python results="asis"}
print("**This text** will be bold...")
```
</file>

<file path="pymdknit/tests/__init__.py">
# Copyright (c) Jan Schulz <jasc@gmx.net>
# Distributed under the terms of the Modified BSD License.


import codecs
import glob
import inspect
import os
import re
import tempfile
import unittest

from pymdknit.py3compat import PY3
from pymdknit.pymdknit import PyMdKnit


def _add_test_cases(cls, foldername):
    """Adds one testcase for each input file in the 'test_dir'

    You have to build a TestCase class, with a _output_test(self, input_file, output_file)
    method and a tests_dir property, which is simply the name of the dir, where the test cases
    are in.

    The inputs for the test cases have to have a file ending "*_input.pymd" and the outputs have
    to end in "*_output.md".

    The `_output_test` method has to convert input and then test for equality with the output.

    The generated test methods will be called `test_something` for `something_input.pymd`.
    """
    # Put them together to make a list of new test functions.
    # One test function for each input file

    tests_dir = os.path.join(os.path.dirname(inspect.getfile(cls)), foldername)
    test_cases_glob = os.path.join(tests_dir, "*.pymd")
    testcases = glob.glob(test_cases_glob)

    function = cls._output_test

    for input_file in testcases:
        # remove ".pymd" from filename
        basename = os.path.splitext(os.path.basename(input_file))[0]
        output_file = os.path.join(tests_dir, basename + ".md")

        # the complicated syntax is needed to get the individual input files into the method...
        # http://math.andrej.com/2009/04/09/pythons-lambda-is-broken/comment-page-1/
        def test_function(self, input_file=input_file, output_file=output_file):
            function(self, input_file, output_file)

        name = f"test_{foldername}_{basename}"
        test_function.__name__ = str(name)
        setattr(cls, name, test_function)


class AbstractOutputTestCase(unittest.TestCase):
    # <ipython-input-2-fb4ced135814>
    _re_ipython_id = re.compile(r"<ipython-input-[0-9]+-[a-z0-9]+>")

    def setUp(self):
        self.maxDiff = None
        self.knitpy = PyMdKnit()

    def _output_test(self, input_file, output_file):
        with codecs.open(input_file, "r", "UTF-8") as f:
            input = f.read()

        # some exceptions are different on py2 and py3, so add a way to make both happy...
        # the version which were used to develop the tests (currently py2) should stay '.md' and
        # the exception should become '.md_pyX'
        if PY3:
            if os.path.exists(output_file + "_py3"):
                output_file = output_file + "_py3"
        else:
            if os.path.exists(output_file + "_py2"):
                output_file = output_file + "_py2"

        output = self.knitpy._knit(input, tempfile.gettempdir())

        if not os.path.exists(output_file):
            _file = output_file + ".off"
            with codecs.open(_file, "w", "UTF-8") as f:
                output = self._re_ipython_id.sub("<ipython-input>", output)
                output = output.replace(os.linesep, "\n")
                f.write(output)
            self.fail(
                "Output does not exist, created one as %s. Remove '.off' to enable it."
            )

        with codecs.open(output_file, "r", "UTF-8") as f:
            exp = f.read()
        self.assert_equal_output(exp, output, filename=output_file)

    def assert_equal_output(self, expected, received, filename=None):
        # output written to a file does not seem to have os.linesep
        # handle everything here by replacing the os linesep by a simple \n
        expected = expected.replace(os.linesep, "\n").rstrip("\n")
        received = received.replace(os.linesep, "\n").rstrip("\n")
        # in errors, there is a unique id like  <ipython-input-2-fb4ced135814>
        received = self._re_ipython_id.sub("<ipython-input>", received)
        # this is a hardcoded fix for py3, where there are quotes around the module:
        received = received.replace("'NoneExistingModule'", "NoneExistingModule")

        if filename and expected != received:
            _file = filename + ".received"
            with codecs.open(_file, "w", "UTF-8") as f:
                f.write(received)

        self.assertEqual(expected, received)
</file>

<file path="pymdknit/tests/test_conversion.py">
#!/usr/bin/env python

# Copyright (c) Jan Schulz <jasc@gmx.net>
# Distributed under the terms of the Modified BSD License.

import unittest

from pymdknit.tests import AbstractOutputTestCase, _add_test_cases


class OutputTestCase(AbstractOutputTestCase):
    pass


_add_test_cases(OutputTestCase, "basics")
_add_test_cases(OutputTestCase, "chunk_options")


if __name__ == "__main__":
    unittest.main()
</file>

<file path="pymdknit/__init__.py">
__author__ = "jschulz"

__all__ = ["pymdknit", "render"]

from .pymdknit import PyMdKnit


def render(filename, output=None):
    """Convert the filename to the given output format(s).

    Returns
    -------
    converted_docs : list
        List of filenames for the converted documents

    """
    kp = PyMdKnit()
    return kp.render(filename, output=output)
</file>

<file path="pymdknit/documents.py">
import os
import re
import tempfile
from collections import OrderedDict

try:
    # py3
    from base64 import decodebytes
except ImportError:
    # py2
    from base64 import decodestring as decodebytes

from pypandoc import convert as pandoc
from traitlets import Bool, CaselessStrEnum, Instance, List, Unicode
# Basic things from IPython
from traitlets.config.configurable import LoggingConfigurable

from .py3compat import iteritems
from .utils import is_iterable, is_string

TEXT, OUTPUT, CODE, ASIS = "text", "output", "code", "asis"


IMAGE_MIMETYPE_TO_FILEEXTENSION = OrderedDict(
    [
        ("image/png", "png"),
        ("image/svg+xml", "svg"),
        ("image/jpeg", "jpg"),
        ("application/pdf", "pdf"),
    ]
)
IMAGE_FILEEXTENSION_TO_MIMETYPE = {
    v: k for k, v in iteritems(IMAGE_MIMETYPE_TO_FILEEXTENSION)
}

MARKUP_FORMAT_CONVERTER = OrderedDict(
    [
        ("text/markdown", "markdown"),
        ("text/x-markdown", "markdown"),
        ("text/html", "html"),
        ("text/latex", "latex"),
    ]
)


class KnitpyOutputException(Exception):
    pass


# this is the intersection of what matplotlib supports (eps, pdf, pgf, png, ps, raw, rgba, svg,
# svgz) and what IPython supports ('png', 'png2x', 'retina', 'jpg', 'jpeg', 'svg', 'pdf')...
_possible_image_formats = CaselessStrEnum(values=["pdf", "png", "svg"])

DEFAULT_FINAL_OUTPUT_FORMATS = [
    {
        "name": "html_document",
        "alias": "html",
        "pandoc_export_format": "html",
        "file_extension": "html",
        "accepted_image_formats": ["png", "svg"],
    },
    {
        "name": "word_document",
        "alias": "docx",
        "pandoc_export_format": "docx",
        "file_extension": "docx",
        "accepted_image_formats": ["png", "svg"],
    },
    {
        "name": "pdf_document",
        "alias": "pdf",
        "pandoc_export_format": "latex",
        "file_extension": "pdf",
        "accepted_image_formats": ["pdf", "png"],
    },
    {
        "name": "latex_document",
        "alias": "latex",
        "pandoc_export_format": "latex",
        "file_extension": "tex",
        "accepted_image_formats": ["pdf", "png"],
    },
]
VALID_OUTPUT_FORMAT_NAMES = [fmt["name"] for fmt in DEFAULT_FINAL_OUTPUT_FORMATS] + [
    fmt["alias"] for fmt in DEFAULT_FINAL_OUTPUT_FORMATS
]

DEFAULT_OUTPUT_FORMAT_NAME = "html_document"


class FinalOutputConfiguration(LoggingConfigurable):
    """
    This class holds configuration information about the final output document.
    """

    name = Unicode("html_document", help="The name of this type of documents")

    alias = Unicode("html", help="The alias of this type of documents")

    pandoc_export_format = Unicode("html", help="The name of the pandoc export format")

    file_extension = Unicode("html", help="The file extension")

    keep_md = Bool(False, help="Whether to keep the temporary markdown file.")

    accepted_image_formats = List(
        trait=_possible_image_formats,
        default_value=["png", "svg"],  # that's for html, which does not use pdf
        config=False,
        help="""The accepted image formats.""",
    )

    # This is atomatically filled from accepted_image_formats
    accepted_image_mimetypes = List(
        config=False,
        default_value=[
            IMAGE_FILEEXTENSION_TO_MIMETYPE[ifmt] for ifmt in ["png", "jpg", "svg"]
        ],
    )

    def _accepted_image_formats_changed(self, name, old, new):
        if new != old:
            converted = [IMAGE_FILEEXTENSION_TO_MIMETYPE[ifmt] for ifmt in new]
            self.accepted_image_mimetypes = converted

    def update(self, **config):
        """Update this

        :param config: dict of properties to be updated
        """
        for name, config_value in iteritems(config):
            if hasattr(self, name):
                setattr(self, name, config_value)
            else:
                self.log.error(
                    "Unknown config for document '%s': '%s:%s'. Ignored...",
                    self.name,
                    name,
                    config_value,
                )

    def copy(self):
        """Copy Constructor

        :return: copy of self
        """
        config = {}
        for name in self.trait_names():
            config[name] = getattr(self, name)
        new_fod = type(self)(**config)
        return new_fod


class TemporaryOutputDocument(LoggingConfigurable):
    output_debug = Bool(
        False, config=True, help="""Whether to print outputs to the (debug) log"""
    )
    # TODO: put loglevel to debug of this is True...

    code_startmarker = Unicode(
        "```{}",
        config=True,
        help="Start of a code block, with language placeholder and without linefeed",
    )
    code_endmarker = Unicode(
        "```", config=True, help="end of a code block, without linefeed"
    )
    output_startmarker = Unicode(
        "```", config=True, help="Start of a output block, without linefeed"
    )
    output_endmarker = Unicode(
        "```", config=True, help="End of a output block, without linefeed"
    )

    error_line = Unicode(
        "**ERROR**: {}",
        config=True,
        help="error message line, with msg placeholder and without linefeed",
    )

    export_config = Instance(
        klass=FinalOutputConfiguration, help="Final output document configuration"
    )

    plot_mimetypes = List(
        default_value=list(IMAGE_MIMETYPE_TO_FILEEXTENSION.keys()),
        allow_none=False,
        config=True,
        help="Mimetypes, which should be handled as plots.",
    )

    markup_mimetypes = List(
        default_value=list(MARKUP_FORMAT_CONVERTER.keys()),
        allow_none=False,
        config=True,
        help="Mimetypes, which should be handled as markeduped text",
    )

    context = Instance(
        klass="pymdknit.pymdknit.ExecutionContext", config=False, allow_none=True
    )

    def __init__(self, fileoutputs, export_config, **kwargs):
        super().__init__(**kwargs)
        self._fileoutputs = fileoutputs
        self.export_config = export_config
        self._output = []
        # Init the caching system (class variables cache the first output of a former conversion
        # in future runs)
        self._last_content = None
        self._cache_text = []
        self._cache_code = []
        self._cache_code_language = None
        self._cache_output = []

    @property
    def outputdir(self):
        if not os.path.isdir(self._fileoutputs):
            os.mkdir(self._fileoutputs)
            self.log.info(
                "Support files will be in %s", os.path.join(self._fileoutputs, "")
            )

        return self._fileoutputs

    @property
    def plotdir(self):
        plotdir_name = "figure-%s" % self.export_config.file_extension
        plotdir = os.path.join(self.outputdir, plotdir_name)
        if not os.path.isdir(plotdir):
            os.mkdir(plotdir)
        return plotdir

    @property
    def content(self):
        self.flush()
        return "".join(self._output)

    # The caching system is needed to make fusing together same "type" of content possible
    # -> code inputs without output should go to the same block

    def _ensure_newline(self):
        # don't add a newline before any output
        if not self._output:
            return
        last_content = self._output[-1]
        while last_content == "":
            del self._output[-1]
            last_content = self._output[-1]
        if last_content[-1] != "\n":
            self._output.append("\n")

    def flush(self):
        if self.output_debug:
            self.log.debug("Flushing caches in output.")
        if self._cache_text:
            self._output.extend(self._cache_text)
            self._cache_text = []
        if self._cache_code:
            self._ensure_newline()
            self._output.append(self.code_startmarker.format(self._cache_code_language))
            self._output.append("\n")
            self._output.extend(self._cache_code)
            self._ensure_newline()
            self._output.append(self.code_endmarker)
            self._output.append("\n")
            self._cache_code = []
            self._cache_code_language = None
        if self._cache_output:
            self._ensure_newline()
            self._output.append(self.output_startmarker)
            self._output.append("\n")
            comment = self.context.comment
            if comment:
                comment = str(comment) + " "
                outputs = "".join(self._cache_output)
                outputs = outputs[:-1] if outputs[-1] == "\n" else outputs
                outputs = outputs.split("\n")
                outputs = [comment + line + "\n" for line in outputs]
                self._output.extend(outputs)
            else:
                self._output.extend(self._cache_output)
                self._ensure_newline()
            self._output.append(self.output_endmarker)
            self._output.append("\n")
            self._cache_output = []

    def _add_to_cache(self, content, content_type):
        if is_string(content):
            content = [content]
        elif is_iterable(content):
            pass
        else:
            content = ["%s" % content]

        # remove empty lines, which causes errors in _ensure_newline
        content = [line for line in content if line != ""]

        if self.output_debug:
            if content_type == CODE:
                _type = f"{content_type} ({self._cache_code_language})"
            else:
                _type = content_type
            self.log.debug("Adding '%s': %s", _type, content)

        if self._last_content and (content_type != self._last_content):
            self.flush()
            if self._output:
                # make sure there is a empty line before the next differently formatted part,
                # so that pandoc doesn't get confused...
                # only add such a line if we are between our own generated content, i.e. between
                # code and output or output and new code
                _nl_between = [CODE, OUTPUT, ASIS]
                if (self._last_content in _nl_between) and (
                    content_type in _nl_between
                ):
                    self._output.append("\n")
        if content_type == CODE:
            cache = self._cache_code
            self._last_content = CODE
        elif content_type == OUTPUT:
            cache = self._cache_output
            self._last_content = OUTPUT
        elif content_type == ASIS:
            # Just use text
            cache = self._cache_text
            self._last_content = ASIS
        else:
            cache = self._cache_text
            self._last_content = TEXT

        cache.extend(content)

    def add_code(self, code, language="python"):
        if self._cache_code_language and (language != self._cache_code_language):
            self.flush()
        self._cache_code_language = language
        self._add_to_cache(code, CODE)

    def add_output(self, output):
        self._add_to_cache(output, OUTPUT)

    def add_text(self, text):
        self._add_to_cache(text, TEXT)

    def add_asis(self, content):
        self._add_to_cache(content, ASIS)

    def add_image(self, mimetype, mimedata, title=""):
        try:
            mimedata = decodebytes(mimedata.encode())
            # save as a file
            if self.context is not None:
                filename = "{}-{}.{}".format(
                    self.context.chunk_label,
                    self.context.chunk_plot_number,
                    IMAGE_MIMETYPE_TO_FILEEXTENSION[mimetype],
                )
                f = open(os.path.join(self.plotdir, filename), mode="w+b")
            else:
                self.log.info("Context no specified: using random filename for image")
                f = tempfile.NamedTemporaryFile(
                    suffix="." + IMAGE_MIMETYPE_TO_FILEEXTENSION[mimetype],
                    prefix="plot",
                    dir=self.plotdir,
                    mode="w+b",
                    delete=False,
                )
            f.write(mimedata)
            f.close()
            relative_name = "{}/{}/{}".format(
                self.outputdir, os.path.basename(self.plotdir), os.path.basename(f.name)
            )
            self.log.info("Written file of type %s to %s", mimetype, relative_name)
            template = "![%s](%s)"
            self.add_asis("\n")
            self.add_asis(template % (title, relative_name))
            self.add_asis("\n")
        except Exception as e:
            self.log.exception("Could not save a image")
            raise KnitpyOutputException(str(e))

    def add_markup_text(self, mimetype, mimedata):
        # workaround for some pandoc weirdness:
        # pandoc interprets html with indention as code and formats it with pre
        # So remove all linefeeds/whitespace...
        if mimetype == "text/html":
            res = []
            for line in mimedata.split("\n"):
                res.append(line.strip())
            mimedata = "".join(res)
            # pandas adds multiple spaces if one element in a column is long, but the rest is
            # short. Remove these spaces, as pandoc doesn't like them...
            mimedata = re.sub(" +", " ", mimedata)

        to_format = "markdown"
        # try to convert to the current format so that it can be included "asis"
        if MARKUP_FORMAT_CONVERTER[mimetype] not in [
            to_format,
            self.export_config.pandoc_export_format,
        ]:
            if "<table" in mimedata:
                # There is a bug in pandoc <=1.13.2, where th in normal tr is triggers "only
                # text" conversion.
                msg = "Trying to fix tables for conversion with pandoc (bug in pandoc <=1.13.2)."
                self.log.debug(msg)
                mimedata = self._fix_html_tables_old_pandoc(mimedata)

            try:
                self.log.debug(
                    "Converting markup of type '%s' to '%s' via pandoc...",
                    mimetype,
                    to_format,
                )
                mimedata = pandoc(
                    mimedata, to=to_format, format=MARKUP_FORMAT_CONVERTER[mimetype]
                )
            except RuntimeError as e:
                # these are pypandoc errors
                msg = "Could not convert mime data of type '%s' to output format '%s'."
                self.log.debug(msg, mimetype, to_format)
                raise KnitpyOutputException(str(e))
            except Exception as e:
                msg = "Could not convert mime data of type '%s' to output format '%s'."
                self.log.exception(msg, mimetype, to_format)
                raise KnitpyOutputException(str(e))

        self.add_asis("\n")
        self.add_asis(mimedata)
        self.add_asis("\n")

    def _fix_html_tables_old_pandoc(self, htmlstring):
        """
        Fix html tables, so that they are recognized by pandoc

        pandoc in <=1.13.2 converts tables with '<th>' and <td> to plain text (each cell one
        paragraph. Remove all <th> in later rows (tbody) by replacing it with <td>. This is
        close to the same solution as taken by pandoc in 1.13.3 and later.

        See also: https://github.com/jgm/pandoc/issues/2015
        """
        result = []
        pos = 0
        re_tables = re.compile(r"<table.*</table>", re.DOTALL)
        re_tbody = re.compile(r"<tbody.*</tbody>", re.DOTALL)
        tables = re_tables.finditer(htmlstring)
        for table in tables:
            # process the html before the match
            result.append(htmlstring[pos : table.start()])
            # now the table itself
            table_html = htmlstring[table.start() : table.end()]
            tbody = re_tbody.search(table_html)
            if tbody is not None:
                result.append(table_html[0 : tbody.start()])
                tbody_html = table_html[tbody.start() : tbody.end()]
                tbody_html = tbody_html.replace("<th", "<td")
                tbody_html = tbody_html.replace("</th>", "</td>")
                result.append(tbody_html)
                result.append(table_html[tbody.end() :])
            else:
                result.append(table_html)
            pos = table.end()
        result.append(htmlstring[pos:])

        return "".join(result)

    def add_execution_error(self, error, details=""):
        # adding an error is considered "not normal", so we make sure it is clearly visible
        self.flush()
        # Set this to None, so no newline is added by accident. We will handle newlines after
        # the error in this code
        self._last_content = None
        # make sure there is a empty line before and after the error message
        self._ensure_newline()
        self._output.append("\n")
        self._output.append(self.error_line.format(error))
        self._output.append("\n\n")
        if details:
            self._output.append(self.output_startmarker)
            self._output.append("\n")
            self._output.append(details)
            self._ensure_newline()
            self._output.append(self.output_endmarker)
            self._output.append("\n\n")
</file>

<file path="pymdknit/encoding.py">
"""
Utilities for dealing with text encodings
"""

# -----------------------------------------------------------------------------
#  Copyright (C) 2008-2012  The IPython Development Team
#
#  Distributed under the terms of the BSD License.  The full license is in
#  the file COPYING, distributed as part of this software.
# -----------------------------------------------------------------------------

import locale
# -----------------------------------------------------------------------------
# Imports
# -----------------------------------------------------------------------------
import sys
import warnings


# to deal with the possibility of sys.std* not being a stream at all
def get_stream_enc(stream, default=None):
    """Return the given stream's encoding or a default.

    There are cases where ``sys.std*`` might not actually be a stream, so
    check for the encoding attribute prior to returning it, and return
    a default if it doesn't exist or evaluates as False. ``default``
    is None if not provided.
    """
    if not hasattr(stream, "encoding") or not stream.encoding:
        return default
    else:
        return stream.encoding


# Less conservative replacement for sys.getdefaultencoding, that will try
# to match the environment.
# Defined here as central function, so if we find better choices, we
# won't need to make changes all over IPython.
def getdefaultencoding(prefer_stream=True):
    """Return IPython's guess for the default encoding for bytes as text.

    If prefer_stream is True (default), asks for stdin.encoding first,
    to match the calling Terminal, but that is often None for subprocesses.

    Then fall back on locale.getpreferredencoding(),
    which should be a sensible platform default (that respects LANG environment),
    and finally to sys.getdefaultencoding() which is the most conservative option,
    and usually ASCII on Python 2 or UTF8 on Python 3.
    """
    enc = None
    if prefer_stream:
        enc = get_stream_enc(sys.stdin)
    if not enc or enc == "ascii":
        try:
            # There are reports of getpreferredencoding raising errors
            # in some cases, which may well be fixed, but let's be conservative here.
            enc = locale.getpreferredencoding()
        except Exception:
            pass
    enc = enc or sys.getdefaultencoding()
    # On windows `cp0` can be returned to indicate that there is no code page.
    # Since cp0 is an invalid encoding return instead cp1252 which is the
    # Western European default.
    if enc == "cp0":
        warnings.warn(
            "Invalid code page cp0 detected - using cp1252 instead."
            "If cp1252 is incorrect please ensure a valid code page "
            "is defined for the process.",
            RuntimeWarning,
        )
        return "cp1252"
    return enc


DEFAULT_ENCODING = getdefaultencoding()
</file>

<file path="pymdknit/engines.py">
__all__ = ["PythonKnitpyEngine"]

LANGUAGE_ENGINES = []

from traitlets.config.configurable import LoggingConfigurable


class BaseKnitpyEngine(LoggingConfigurable):
    name = "<NOT_EXISTANT>"
    kernel_name = "<NOT_EXISTANT>"
    startup_lines = ""
    language = "<NOT_EXISTANT>"  # for syntax highlighting...

    @property
    def kernel(self):
        return self.parent._get_kernel(self)

    def get_plotting_format_code(self, formats):
        """
        Enables the supplied plotting formats in the backend

        formats : list of strings
             the plotting formats. e.g. `["pdf", "png", "jpeg"]`

        returns string
            The code which should be run on the kernel to set the default plotting formats
        """
        raise NotImplementedError


class PythonKnitpyEngine(BaseKnitpyEngine):
    name = "python"
    kernel_name = "python"
    startup_lines = (
        "# Bad things happen if tracebacks have ansi escape sequences\n"
        + "%colors NoColor\n"
    )
    language = "python"

    def get_plotting_format_code(self, formats):
        valid_formats = ["png", "jpg", "jpeg", "pdf"]
        code = (
            "%matplotlib inline\n"
            + "from IPython.display import set_matplotlib_formats\n"
            + "set_matplotlib_formats({0})\n"
        )
        formats = [fmt for fmt in formats if fmt in valid_formats]
        if not formats:
            raise Exception("No valid output format found! Aborting...")

        fmt_string = "', '".join(formats)
        fmt_string = "'" + fmt_string + "'"
        return code.format(fmt_string)
</file>

<file path="pymdknit/path.py">
"""
Utilities for path handling.
"""

# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.

import errno
import os
import random
import shutil
import sys

from . import py3compat

fs_encoding = sys.getfilesystemencoding()


def filefind(filename, path_dirs=None):
    """Find a file by looking through a sequence of paths.

    This iterates through a sequence of paths looking for a file and returns
    the full, absolute path of the first occurence of the file.  If no set of
    path dirs is given, the filename is tested as is, after running through
    :func:`expandvars` and :func:`expanduser`.  Thus a simple call::

        filefind('myfile.txt')

    will find the file in the current working dir, but::

        filefind('~/myfile.txt')

    Will find the file in the users home directory.  This function does not
    automatically try any paths, such as the cwd or the user's home directory.

    Parameters
    ----------
    filename : str
        The filename to look for.
    path_dirs : str, None or sequence of str
        The sequence of paths to look for the file in.  If None, the filename
        need to be absolute or be in the cwd.  If a string, the string is
        put into a sequence and the searched.  If a sequence, walk through
        each element and join with ``filename``, calling :func:`expandvars`
        and :func:`expanduser` before testing for existence.

    Returns
    -------
    Raises :exc:`IOError` or returns absolute path to file.
    """

    # If paths are quoted, abspath gets confused, strip them...
    filename = filename.strip('"').strip("'")
    # If the input is an absolute path, just check it exists
    if os.path.isabs(filename) and os.path.isfile(filename):
        return filename

    if path_dirs is None:
        path_dirs = ("",)
    elif isinstance(path_dirs, py3compat.string_types):
        path_dirs = (path_dirs,)

    for path in path_dirs:
        if path == ".":
            path = py3compat.getcwd()
        testname = expand_path(os.path.join(path, filename))
        if os.path.isfile(testname):
            return os.path.abspath(testname)

    raise OSError(
        f"File {filename!r} does not exist in any of the search paths: {path_dirs!r}"
    )


def expand_path(s):
    """Expand $VARS and ~names in a string, like a shell

    :Examples:

       In [2]: os.environ['FOO']='test'

       In [3]: expand_path('variable FOO is $FOO')
       Out[3]: 'variable FOO is test'
    """
    # This is a pretty subtle hack. When expand user is given a UNC path
    # on Windows (\\server\share$\%username%), os.path.expandvars, removes
    # the $ to get (\\server\share\%username%). I think it considered $
    # alone an empty var. But, we need the $ to remains there (it indicates
    # a hidden share).
    if os.name == "nt":
        s = s.replace("$\\", "IPYTHON_TEMP")
    s = os.path.expandvars(os.path.expanduser(s))
    if os.name == "nt":
        s = s.replace("IPYTHON_TEMP", "$\\")
    return s


try:
    ENOLINK = errno.ENOLINK
except AttributeError:
    ENOLINK = 1998


def link(src, dst):
    """Hard links ``src`` to ``dst``, returning 0 or errno.

    Note that the special errno ``ENOLINK`` will be returned if ``os.link`` isn't
    supported by the operating system.
    """

    if not hasattr(os, "link"):
        return ENOLINK
    link_errno = 0
    try:
        os.link(src, dst)
    except OSError as e:
        link_errno = e.errno
    return link_errno


def link_or_copy(src, dst):
    """Attempts to hardlink ``src`` to ``dst``, copying if the link fails.

    Attempts to maintain the semantics of ``shutil.copy``.

    Because ``os.link`` does not overwrite files, a unique temporary file
    will be used if the target already exists, then that file will be moved
    into place.
    """

    if os.path.isdir(dst):
        dst = os.path.join(dst, os.path.basename(src))

    link_errno = link(src, dst)
    if link_errno == errno.EEXIST:
        if os.stat(src).st_ino == os.stat(dst).st_ino:
            # dst is already a hard link to the correct file, so we don't need
            # to do anything else. If we try to link and rename the file
            # anyway, we get duplicate files - see http://bugs.python.org/issue21876
            return

        new_dst = dst + f"-temp-{random.randint(1, 16**4):04X}"
        try:
            link_or_copy(src, new_dst)
        except:
            try:
                os.remove(new_dst)
            except OSError:
                pass
            raise
        os.rename(new_dst, dst)
    elif link_errno != 0:
        # Either link isn't supported, or the filesystem doesn't support
        # linking, or 'src' and 'dst' are on different filesystems.
        shutil.copy(src, dst)


def ensure_dir_exists(path, mode=0o755):
    """ensure that a directory exists

    If it doesn't exist, try to create it and protect against a race condition
    if another process is doing the same.

    The default permissions are 755, which differ from os.makedirs default of 777.
    """
    if not os.path.exists(path):
        try:
            os.makedirs(path, mode=mode)
        except OSError as e:
            if e.errno != errno.EEXIST:
                raise
    elif not os.path.isdir(path):
        raise OSError("%r exists but is not a directory" % path)
</file>

<file path="pymdknit/py3compat.py">
"""Compatibility tricks for Python 3. Mainly to do with unicode."""

import functools
import os
import re
import shutil
import sys
import types

from .encoding import DEFAULT_ENCODING


def no_code(x, encoding=None):
    return x


def decode(s, encoding=None):
    encoding = encoding or DEFAULT_ENCODING
    return s.decode(encoding, "replace")


def encode(u, encoding=None):
    encoding = encoding or DEFAULT_ENCODING
    return u.encode(encoding, "replace")


def cast_unicode(s, encoding=None):
    if isinstance(s, bytes):
        return decode(s, encoding)
    return s


def cast_bytes(s, encoding=None):
    if not isinstance(s, bytes):
        return encode(s, encoding)
    return s


def buffer_to_bytes(buf):
    """Cast a buffer or memoryview object to bytes"""
    if isinstance(buf, memoryview):
        return buf.tobytes()
    if not isinstance(buf, bytes):
        return bytes(buf)
    return buf


def _modify_str_or_docstring(str_change_func):
    @functools.wraps(str_change_func)
    def wrapper(func_or_str):
        if isinstance(func_or_str, string_types):
            func = None
            doc = func_or_str
        else:
            func = func_or_str
            doc = func.__doc__

        doc = str_change_func(doc)

        if func:
            func.__doc__ = doc
            return func
        return doc

    return wrapper


def safe_unicode(e):
    """unicode(e) with various fallbacks. Used for exceptions, which may not be
    safe to call unicode() on.
    """
    try:
        return unicode_type(e)
    except UnicodeError:
        pass

    try:
        return str_to_unicode(str(e))
    except UnicodeError:
        pass

    try:
        return str_to_unicode(repr(e))
    except UnicodeError:
        pass

    return "Unrecoverably corrupt evalue"


# shutil.which from Python 3.4
def _shutil_which(cmd, mode=os.F_OK | os.X_OK, path=None):
    """Given a command, mode, and a PATH string, return the path which
    conforms to the given mode on the PATH, or None if there is no such
    file.

    `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result
    of os.environ.get("PATH"), or can be overridden with a custom search
    path.

    This is a backport of shutil.which from Python 3.4
    """

    # Check that a given file can be accessed with the correct mode.
    # Additionally check that `file` is not a directory, as on Windows
    # directories pass the os.access check.
    def _access_check(fn, mode):
        return os.path.exists(fn) and os.access(fn, mode) and not os.path.isdir(fn)

    # If we're given a path with a directory part, look it up directly rather
    # than referring to PATH directories. This includes checking relative to the
    # current directory, e.g. ./script
    if os.path.dirname(cmd):
        if _access_check(cmd, mode):
            return cmd
        return None

    if path is None:
        path = os.environ.get("PATH", os.defpath)
    if not path:
        return None
    path = path.split(os.pathsep)

    if sys.platform == "win32":
        # The current directory takes precedence on Windows.
        if os.curdir not in path:
            path.insert(0, os.curdir)

        # PATHEXT is necessary to check on Windows.
        pathext = os.environ.get("PATHEXT", "").split(os.pathsep)
        # See if the given file matches any of the expected path extensions.
        # This will allow us to short circuit when given "python.exe".
        # If it does match, only test that one, otherwise we have to try
        # others.
        if any(cmd.lower().endswith(ext.lower()) for ext in pathext):
            files = [cmd]
        else:
            files = [cmd + ext for ext in pathext]
    else:
        # On other platforms you don't have things like PATHEXT to tell you
        # what file suffixes are executable, so just pass on cmd as-is.
        files = [cmd]

    seen = set()
    for dir in path:
        normdir = os.path.normcase(dir)
        if normdir not in seen:
            seen.add(normdir)
            for thefile in files:
                name = os.path.join(dir, thefile)
                if _access_check(name, mode):
                    return name
    return None


if sys.version_info[0] >= 3:
    PY3 = True

    # keep reference to builtin_mod because the kernel overrides that value
    # to forward requests to a frontend.
    def input(prompt=""):
        return builtin_mod.input(prompt)

    builtin_mod_name = "builtins"
    import builtins as builtin_mod

    str_to_unicode = no_code
    unicode_to_str = no_code
    str_to_bytes = encode
    bytes_to_str = decode
    cast_bytes_py2 = no_code
    cast_unicode_py2 = no_code
    buffer_to_bytes_py2 = no_code

    string_types = (str,)
    unicode_type = str

    which = shutil.which

    def isidentifier(s, dotted=False):
        if dotted:
            return all(isidentifier(a) for a in s.split("."))
        return s.isidentifier()

    xrange = range

    def iteritems(d):
        return iter(d.items())

    def itervalues(d):
        return iter(d.values())

    getcwd = os.getcwd

    MethodType = types.MethodType

    def execfile(fname, glob, loc=None, compiler=None):
        loc = loc if (loc is not None) else glob
        with open(fname, "rb") as f:
            compiler = compiler or compile
            exec(compiler(f.read(), fname, "exec"), glob, loc)

    # Refactor print statements in doctests.
    _print_statement_re = re.compile(r"\bprint (?P<expr>.*)$", re.MULTILINE)

    def _print_statement_sub(match):
        expr = match.groups("expr")
        return "print(%s)" % expr

    @_modify_str_or_docstring
    def doctest_refactor_print(doc):
        """Refactor 'print x' statements in a doctest to print(x) style. 2to3
        unfortunately doesn't pick up on our doctests.

        Can accept a string or a function, so it can be used as a decorator."""
        return _print_statement_re.sub(_print_statement_sub, doc)

    # Abstract u'abc' syntax:
    @_modify_str_or_docstring
    def u_format(s):
        """ "{u}'abc'" --> "'abc'" (Python 3)

        Accepts a string or a function, so it can be used as a decorator."""
        return s.format(u="")

    def get_closure(f):
        """Get a function's closure attribute"""
        return f.__closure__

else:
    PY3 = False

    # keep reference to builtin_mod because the kernel overrides that value
    # to forward requests to a frontend.
    def input(prompt=""):
        return builtin_mod.raw_input(prompt)

    builtin_mod_name = "__builtin__"
    import __builtin__ as builtin_mod

    str_to_unicode = decode
    unicode_to_str = encode
    str_to_bytes = no_code
    bytes_to_str = no_code
    cast_bytes_py2 = cast_bytes
    cast_unicode_py2 = cast_unicode
    buffer_to_bytes_py2 = buffer_to_bytes

    string_types = (str, unicode)
    unicode_type = unicode

    import re

    _name_re = re.compile(r"[a-zA-Z_][a-zA-Z0-9_]*$")

    def isidentifier(s, dotted=False):
        if dotted:
            return all(isidentifier(a) for a in s.split("."))
        return bool(_name_re.match(s))

    xrange = xrange

    def iteritems(d):
        return d.iteritems()

    def itervalues(d):
        return d.itervalues()

    getcwd = os.getcwdu

    def MethodType(func, instance):
        return types.MethodType(func, instance, type(instance))

    def doctest_refactor_print(func_or_str):
        return func_or_str

    def get_closure(f):
        """Get a function's closure attribute"""
        return f.func_closure

    which = _shutil_which

    # Abstract u'abc' syntax:
    @_modify_str_or_docstring
    def u_format(s):
        """ "{u}'abc'" --> "u'abc'" (Python 2)

        Accepts a string or a function, so it can be used as a decorator."""
        return s.format(u="u")

    if sys.platform == "win32":

        def execfile(fname, glob=None, loc=None, compiler=None):
            loc = loc if (loc is not None) else glob
            scripttext = builtin_mod.open(fname).read() + "\n"
            # compile converts unicode filename to str assuming
            # ascii. Let's do the conversion before calling compile
            if isinstance(fname, unicode):
                filename = unicode_to_str(fname)
            else:
                filename = fname
            compiler = compiler or compile
            exec(compiler(scripttext, filename, "exec"), glob, loc)

    else:

        def execfile(fname, glob=None, loc=None, compiler=None):
            if isinstance(fname, unicode):
                filename = fname.encode(sys.getfilesystemencoding())
            else:
                filename = fname
            where = [ns for ns in [glob, loc] if ns is not None]
            if compiler is None:
                builtin_mod.execfile(filename, *where)
            else:
                scripttext = builtin_mod.open(fname).read().rstrip() + "\n"
                exec(compiler(scripttext, filename, "exec"), glob, loc)


def annotate(**kwargs):
    """Python 3 compatible function annotation for Python 2."""
    if not kwargs:
        raise ValueError("annotations must be provided as keyword arguments")

    def dec(f):
        if hasattr(f, "__annotations__"):
            for k, v in kwargs.items():
                f.__annotations__[k] = v
        else:
            f.__annotations__ = kwargs
        return f

    return dec


# Parts below taken from six:
# Copyright (c) 2010-2013 Benjamin Peterson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


def with_metaclass(meta, *bases):
    """Create a base class with a metaclass."""
    return meta("_NewBase", bases, {})
</file>

<file path="pymdknit/pymdknit.py">
#!/usr/bin/env python
"""
pymdknit - knitting python flavoured markdown files
"""

# Copyright (c) Jan Schulz <jasc@gmx.net>
# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.


# -----------------------------------------------------------------------------
# Imports
# -----------------------------------------------------------------------------

import codecs
import datetime
import getpass
import os
import re

import yaml

try:
    from queue import Empty  # Py 3
except ImportError:
    from Queue import Empty  # Py 2

from jupyter_client.kernelspec import KernelSpecManager
# Stuff for the kernels
from jupyter_client.multikernelmanager import MultiKernelManager
from pypandoc import convert as pandoc
from traitlets import (Bool, CaselessStrEnum, CRegExp, Instance, Integer, List,
                       Unicode)
from traitlets.config.configurable import LoggingConfigurable

# Our own stuff
from .documents import (DEFAULT_FINAL_OUTPUT_FORMATS,
                        DEFAULT_OUTPUT_FORMAT_NAME, VALID_OUTPUT_FORMAT_NAMES,
                        FinalOutputConfiguration, KnitpyOutputException,
                        TemporaryOutputDocument)
from .engines import BaseKnitpyEngine, PythonKnitpyEngine
from .path import expand_path
from .py3compat import getcwd, iteritems, unicode_type
from .utils import CRegExpMultiline, _code, _plain_text, is_string

TBLOCK, TINLINE, TTEXT = range(3)


class KnitpyException(Exception):
    pass


class ParseException(KnitpyException):
    pass


class PyMdKnit(LoggingConfigurable):
    """Engine used to convert from python markdown (``*.pymd``) to html/latex/..."""

    keep_md = Bool(
        False, config=True, help="""Whether to keep the temporary md files"""
    )

    log_to_file = Bool(False, config=True, help="""Whether to send the log to a file""")

    extra_document_configs = List(
        default_value=[],
        config=True,
        help="Additional configurations for FinalOutputDocuments",
    )

    default_export_format = CaselessStrEnum(
        VALID_OUTPUT_FORMAT_NAMES,
        default_value=DEFAULT_OUTPUT_FORMAT_NAME,
        config=True,
        help="""The export format to be used (can't by from extra_document_configs!).""",
    )

    kernel_debug = Bool(
        False,
        config=True,
        help="""Whether to output kernel messages to the (debug) log""",
    )

    timeout = Integer(10, config=True, help="timeout for individual code executions")

    # Things for the parser...
    chunk_begin = CRegExpMultiline(
        r"^\s*```+\s*{[.]?(?P<engine>[a-z]+)\s*(?P<args>.*)}\s*$",
        config=True,
        help="chunk begin regex (must include the named group 'engine' and 'args'",
    )
    chunk_end = CRegExpMultiline(r"^\s*```+\s*$", config=True, help="chunk end regex")
    inline_code = CRegExpMultiline(
        r"`(?P<engine>[a-z]+) +([^`]+)\s*`",
        config=True,
        help="inline code regex (must include a named group 'engine')",
    )
    comment_line = CRegExp(r"^\s*#", config=True, help="comment line regex")
    yaml_separator = CRegExpMultiline(
        r"^---\s*$", config=True, help="separator for the yaml metadata"
    )

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.init_kernel_manager()
        self.init_engines()
        self.init_output_configurations()

    def init_kernel_manager(self):
        self._km = MultiKernelManager(log=self.log, parent=self)
        self._ksm = KernelSpecManager(log=self.log, parent=self)
        self._kernels = {}
        # ksm.find_kernel_specs()

    def init_engines(self):
        self._engines = {}
        self._engines["python"] = PythonKnitpyEngine(parent=self)
        # TODO: check that every kernel_name is in ksm.find_kernel_specs()

    def init_output_configurations(self):
        self._outputs = {}
        for config in DEFAULT_FINAL_OUTPUT_FORMATS:
            fod = FinalOutputConfiguration(parent=self, **config)
            self._outputs[config["name"]] = fod
            self._outputs[config["alias"]] = fod
        for config in self.extra_document_configs:
            fod = FinalOutputConfiguration(parent=self, **config)
            self._outputs[config["name"]] = fod
            self._outputs[config["alias"]] = fod

    def parse_document(self, input):
        if os.path.exists(input):
            filename = input
            f = codecs.open(filename, "r", "UTF-8")
            doc = f.read()
        else:
            doc = input
            filename = "anonymous_input"

        # the yaml can stay in the doc, pandoc will remove '---' blocks
        # pandoc will also do it's own interpretation and use title/author and so on...
        # ToDo: not sure of that should stay or if we should start with clean metadata
        # title, author, date
        # title: "A first try"
        # author: "Jan Schulz"
        # date: "Monday, February 23, 2015"
        # default values
        metadata = {
            "title": filename,
            "author": getpass.getuser(),
            "date": datetime.datetime.now().strftime("%A, %B %d, %Y"),
        }

        pos = 0
        start = self.yaml_separator.search(doc, pos)
        if start is not None:
            end = self.yaml_separator.search(doc, start.end())
            if end is None:
                raise ParseException("Found no metadata end separator.")
            try:
                res = yaml.load(doc[start.end() : end.start()])
                self.log.debug("Metadata: %s", res)
                metadata.update(res)
            except Exception as e:
                raise ParseException("Malformed metadata: %s" % str(e))

        parsed_doc = self._parse_blocks(doc)
        return parsed_doc, metadata

    def _parse_blocks(self, doc):
        result = []
        doc_pos = 0
        blocks = self.chunk_begin.finditer(doc)
        for block_start in blocks:
            # process the text before the match
            text = doc[doc_pos : block_start.start()]
            self._parse_inline(text, result)
            # TODO: somehow a empty line before a codeblock vanishes, so add one here
            result.append((TTEXT, "\n"))
            # now the block itself
            # find the end of the block
            block_end = self.chunk_end.search(doc, block_start.end())
            if block_end is None:
                raise ParseException(
                    "Found no end for the block starting at pos %s" % block_start.end()
                )
            result.append(
                (
                    TBLOCK,
                    (
                        doc[block_start.end() : block_end.start()],
                        block_start.groupdict(),
                    ),
                )
            )
            doc_pos = block_end.end()
        # text after the last block
        self._parse_inline(doc[doc_pos:], result)
        return result

    def _parse_inline(self, text, result):
        text_pos = 0
        for inline in self.inline_code.finditer(text):
            # text before inline code
            result.append((TTEXT, text[text_pos : inline.start()]))
            # inline code
            engine_offset = len(inline.group("engine")) + 1
            result.append(
                (
                    TINLINE,
                    (
                        text[inline.start() + engine_offset + 1 : inline.end() - 1],
                        inline.groupdict(),
                    ),
                )
            )
            text_pos = inline.end()
        # text after the last inline code
        result.append((TTEXT, text[text_pos:]))

    def _all_lines_comments(self, lines):
        for line in lines.split("\n"):
            if not self.comment_line.match(line):
                return False
        return True

    def convert(self, parsed, output):
        context = ExecutionContext(output=output)

        for entry in parsed:
            if entry[0] == TBLOCK:
                context.mode = "block"
                self._process_code(entry[1], context=context)
            elif entry[0] == TINLINE:
                context.mode = "inline"
                self._process_code(entry[1], context=context)
            elif entry[0] == TTEXT:
                output.add_text(entry[1])
            else:
                raise ParseException("Found something unexpected: %s" % entry)
        # process_code opened kernels, so close them here
        self._km.shutdown_all()
        # workaround for https://github.com/ipython/ipython/issues/8007
        # FIXME: remove if IPython >3.0 is in require
        self._km._kernels.clear()
        self._kernels = {}
        return output

    def _process_code(self, input, context):
        context.execution_started()

        # setup the execution context
        code = input[0]
        intro = input[1]
        engine_name = intro["engine"]
        raw_args = intro.get("args", "")

        args = self._parse_args(raw_args)

        # for compatibility with knitr, where python is specified via "{r engine='python'}"
        if "engine" in args:
            engine_name = args.pop("engine")
            self.log.debug("Running on engine: %s", engine_name)

        try:
            engine = self._engines[engine_name]
        except:
            raise ParseException("Unknown codeblock type: %s" % engine_name)
        assert engine is not None, "Engine is None"
        context.engine = engine
        if engine.name not in context.enabled_documents:
            plotting_formats = context.output.export_config.accepted_image_formats
            plot_code = engine.get_plotting_format_code(plotting_formats)
            self._run_silently(context.engine.kernel, plot_code)
            context.enabled_documents.append(engine.name)
            self.log.info(
                "Enabled image formats '%s' in engine '%s'.",
                plotting_formats,
                engine.name,
            )

        # configure the context

        if "include" in args:
            include = args.pop("include")
            if not include:
                context.echo = False
                context.results = "hide"

        if "echo" in args:
            context.echo = args.pop("echo")

        # eval=False means that we don't execute the block at all
        if "eval" in args:
            _eval = args.pop("eval")
            if _eval is False:
                # We still should add the code block if echo is True.
                if context.echo:
                    code = code.replace(os.linesep, "\n").lstrip("\n")
                    context.output.add_code(code, language=engine.language)
                return

        if "results" in args:
            context.results = args.pop("results")

        if "chunk_label" in args:
            context.chunk_label = args.pop("chunk_label")
        else:
            context.chunk_label = "unnamed-chunk-%s" % context.chunk_number

        if "comment" in args:
            context.comment = args.pop("comment")

        if args:
            self.log.debug("Found unhandled args: %s", args)

        lines = ""
        code_lines = code.split("\n")
        space_re = re.compile(r"^([\s]+)")
        spaces = []

        # TODO: this whole "merge with the next line" should be rewritten as a generator
        def loop_continues(line_no):
            if len(code_lines) <= line_no:
                return False

            candidate = code_lines[line_no]
            # comments should be swallowed if a line further down has code in it with the
            # right number of spaces in front
            while candidate.strip() == "" or self._all_lines_comments(candidate):
                line_no += 1
                if len(code_lines) <= line_no:
                    return False
                candidate = code_lines[line_no]
            # the next code line must have either the same number of spaces (still in a loop),
            # or less spaces as in 'spaces' (nested loop) or none (end of loop). If more spaces
            # are found or different types of spaces, this will result in an error which will be
            # shown when the code is executed...
            while spaces:
                possible_space = spaces[-1]
                if candidate[: len(possible_space)] == possible_space:
                    # ok, we are at the "right" level of space
                    return True
                # not our "space", so remove it and try the one one nesting above
                spaces.pop()
            return False

        for line_no in range(len(code_lines)):
            cur_line = code_lines[line_no]
            lines = lines + cur_line
            # check if we are in a loop and if so, if the next line also belongs to this loop
            # this only catches the case where we are *in* a loop and not the loop start (the line
            #  with a ':' in it. That line is catched by the is_complete call below. nested loops
            #  are also catched due to the space in front of it
            m = space_re.match(cur_line)
            if m:
                cur_space = m.group(0)
                spaces.append(cur_space)
                if loop_continues(line_no + 1):
                    lines += "\n"
                    continue

            if spaces:
                # we are in a loop, as spaces has some spaces in it, but the code above didn't find
                # any spaces in front of the line -> this is the case when loop_continues found a
                # new codeline from this loop after a comment with different spaces in front of
                # it or an empty line. This could be such an empty/comment line and we have to
                # look at the next line as well!
                if cur_line.strip() == "" or self._all_lines_comments(cur_line):
                    lines += "\n"
                    continue
            # we have a block of code, including all lines of a loop
            msg = engine.kernel.is_complete(lines + "\n\n")
            reply = engine.kernel.get_shell_msg(timeout=self.timeout)
            assert reply["msg_type"] == "is_complete_reply", str(reply)
            if self.kernel_debug:
                self.log.debug("completion_request: %s", msg)
            if reply["content"]["status"] == "complete":
                if lines.strip() == "":
                    # No requests for "no code"
                    lines = ""
                    continue
                elif self._all_lines_comments(lines):
                    # comments should go to to the next code block
                    lines += "\n"
                    continue
                # run the lines
                self._run_lines(lines + "\n", context)
                lines = ""
            elif reply["content"]["status"] == "invalid":
                # TODO: not sure how this should be handled
                # Either abort execution of the whole file or just retry with the next line?
                # However this should be handled via a user message
                self.log.info("Code invalid:\n%s", lines)
                context.output.add_code(lines, language=engine.language)
                context.output.add_execution_error("Code invalid")
                lines = ""
            else:
                # the "incomplete" case: don't run anything wait for the next line
                lines += "\n"

        # This can only happen if the last line is incomplete
        # This will always result in an error!
        if lines.strip() != "":
            self._run_lines(lines, context)

        context.execution_finished()

    def _parse_args(self, raw_args):
        # Todo: knitr interprets all values, so code references are possible
        # This also means that we have to do args parsing at interpretation time, so that
        # variable from other code can be taken into account..

        args = {}
        if raw_args.strip() == "":
            return args

        converter = {
            "True": True,
            "False": False,
            "None": None,
            "T": True,  # Rs True/False
            "F": False,
            "TRUE": True,
            "FALSE": False,
            # treat Rs NA as None, probably overkill to look for float("NA")
            "NA": None,
            "NULL": None,
        }

        # The first is special as that can be the name of the chunk
        first = True
        for arg in raw_args.split(","):
            arg = arg.strip()
            if "=" not in arg:
                if not first:
                    raise ParseException(
                        "Malformed options for code chunk: '{}' in '{}'".format(
                            arg, raw_args
                        )
                    )
                args["chunk_label"] = arg
                continue
            first = False
            label, value = arg.split("=")
            v = value.strip()
            # convert to real types.
            # TODO: Should be done by submitting the whole thing to the kernel, like knitr does
            # -> variables form one codecell can be used in the args of the next one ...
            if v[0] == '"' and v[-1] == '"':
                v = v[1:-1]
            elif v[0] == "'" and v[-1] == "'":
                v = v[1:-1]
            elif v in converter:
                v = converter[v]
            else:
                try:
                    v = int(v)
                except:
                    self.log.error(
                        "Could not decode option value: '%s=%s'. Discarded...", label, v
                    )
                    continue

            args[label.strip()] = v

        return args

    def _run_lines(self, lines, context):
        kernel = context.engine.kernel
        msg_id = kernel.execute(lines)
        if self.kernel_debug:
            self.log.debug("Executing lines (msg_id=%s):\n%s", msg_id, lines)
        # wait for finish, with timeout
        # At first we have to wait until the kernel tells us it is finished with running the code
        while True:
            try:
                msg = kernel.shell_channel.get_msg(timeout=self.timeout)
                if self.kernel_debug:
                    self.log.debug("shell msg: %s", msg)
            except Empty:
                # This indicates that something bad happened, as AFAIK this should return...
                self.log.error("Timeout waiting for execute reply")
                raise KnitpyException("Timeout waiting for execute reply.")
            if msg["parent_header"].get("msg_id") == msg_id:
                # It's finished, and we got our reply, so next look at the results
                break
            else:
                # not our reply
                self.log.debug("Discarding message from a different client: %s" % msg)
                continue

        # Now look at the results of our code execution and earlier completion requests
        # We handle messages until the kernel indicates it's ide again
        status_idle_again = False
        while True:
            try:
                msg = kernel.get_iopub_msg(timeout=self.timeout)
            except Empty:
                # There should be at least some messages: we just executed code!
                # The only valid time could be when the timeout happened too early (aka long
                # running code in the document) -> we handle that below
                self.log.warn("Timeout waiting for expected IOPub output")
                break

            if msg["parent_header"].get("msg_id") != msg_id:
                if msg["parent_header"].get("msg_type") != "is_complete_request":
                    # not an output from our execution and not one of the complete_requests
                    self.log.debug(
                        "Discarding output from a different client: %s" % msg
                    )
                else:
                    # complete_requests are ok
                    pass
                continue

            # Here we have some message which corresponds to our code execution
            msg_type = msg["msg_type"]
            content = msg["content"]

            # The kernel indicates some status: executing -> idle
            if msg_type == "status":
                if content["execution_state"] == "idle":
                    # When idle, the kernel has executed all input
                    status_idle_again = True
                    break
                else:
                    # the "starting execution" messages
                    continue
            elif msg_type == "clear_output":
                # we don't handle that!?
                self.log.debug("Discarding unexpected 'clear_output' message: %s" % msg)
                continue
            ## So, from here on we have a messages with real content
            if self.kernel_debug:
                self.log.debug("iopub msg (%s): %s", msg_type, msg)
            if context.include:
                self._handle_return_message(msg, context)

        if not status_idle_again:
            self.log.error(
                "Code lines didn't execute in time. Don't use long-running code in "
                "documents or increase the timeout!"
            )
            self.log.error("line(s): %s" % lines)

    def _handle_return_message(self, msg, context):
        if context.mode == "inline":
            # self.log.debug("inline: %s" % msg)
            if msg["msg_type"] == "execute_result":
                context.output.add_text(_plain_text(msg["content"]))
        elif context.mode == "block":
            # self.log.debug("block: %s" % msg)
            type = msg["msg_type"]
            if type == "execute_input":
                if context.echo:
                    context.output.add_code(
                        _code(msg["content"]), language=context.engine.language
                    )
            elif type == "stream":
                # {u'text': u'a\nb\nc\n', u'name': u'stdout'}
                # TODO: format stdout and stderr differently?
                txt = msg["content"].get("text", "")
                if txt.strip() == "":
                    return
                if context.results == "markup":
                    context.output.add_output(txt)
                elif context.results == "asis":
                    context.output.add_asis(txt)
                elif context.results == "hide":
                    return
                else:
                    # TODO: implement a caching system... again...
                    self.log.warn(
                        "Can't handle results='hold' yet, falling back to 'markup'."
                    )
                    context.output.add_output(txt)
            elif (type == "execute_result") or (type == "display_data"):
                if context.results == "hide":
                    return
                if context.results == "hold":
                    self.log.warn(
                        "Can't handle results='hold' yet, falling back to 'markup'."
                    )

                # Here we handle the output from the IPython display framework.
                # 1. If a object has a _display_ipython(), that will be called. This method should
                #    publish (one) display_data message and return -> the content ends up in
                #    "display_data" msg and the "executive_result" has no data
                # 2. else try different IPython.core.formatters for the object, which basically
                #    call the right _repr_<whatever>_ method to get a formated string in that
                #    mimetype. This is added as alternatives under content.data of the
                #    "executive_result".

                # data has/can have multiple types of the same message
                data = msg["content"]["data"]
                # self.log.debug(str(data))

                # handle plots
                # self.log.debug("Accepted image mimetypes: %s", context.output.export_config.accepted_image_mimetypes)
                for mime_type in context.output.export_config.accepted_image_mimetypes:
                    mime_data = data.get(mime_type, None)
                    if mime_data is None:
                        self.log.debug("No image found: %s", mime_type)
                        continue
                    try:
                        self.log.debug("Trying to include image...")
                        context.output.add_image(mime_type, mime_data, title="")
                    except KnitpyOutputException as e:
                        self.log.info("Couldn't include image: %s", e)
                        continue
                    return

                # now try some marked up text formats
                for mime_type in context.output.markup_mimetypes:
                    mime_data = data.get(mime_type, None)
                    if mime_data is None:
                        continue
                    try:
                        self.log.debug("Trying to include markup text...")
                        context.output.add_markup_text(mime_type, mime_data)
                    except KnitpyOutputException as e:
                        self.log.info("Couldn't include markup text: %s", e)
                        continue
                    return

                # as a last resort, try plain text...
                if "text/plain" in data:
                    txt = data.get("text/plain", "")
                    if txt != "":
                        if context.results == "markup":
                            context.output.add_output(txt)
                            if txt[-1] != "\n":
                                context.output.add_output("\n")
                        elif context.results == "asis":
                            context.output.add_asis(txt)
                            if txt[-1] != "\n":
                                context.output.add_asis("\n")

                        return

                # If we are here,  we couldn't handle any of the more specific data types
                # and didn't find any output text
                excuse = "\n(Found data of type '{}', but couldn't handle it)\n"
                context.output.add_output(excuse.format(data.keys()))
            elif type == "error":
                ename = msg["content"].get("ename", "unknown exception")
                evalue = msg["content"].get("evalue", "unknown exception value")
                tb = msg["content"].get("traceback", "<not available>")
                if not is_string(tb):
                    # remove the first line...
                    tb = "\n".join(tb[1:])
                self.log.info(tb)
                # there are ansi escape sequences in the traceback, which kills pandoc :-(
                if "\x1b[1;32m" in tb:
                    tb = (
                        "!! traceback unavailable due to included color sequences;\n"
                        "!! execute `%colors NoColor` once before this line to remove them!"
                    )
                context.output.add_execution_error(f"{ename}: {evalue}", tb)
            else:
                self.log.debug("Ignored msg of type %s" % type)

    def _run_silently(self, kc, lines):
        try:
            msg_id = kc.execute(
                lines + "\n\n", silent=self.kernel_debug, store_history=False
            )
            self.log.debug("Executed silent code: %s", lines)
            reply = kc.get_shell_msg(timeout=self.timeout)
            assert reply["parent_header"].get("msg_id") == msg_id, (
                "Wrong reply! " + str(reply)
            )
            if self.kernel_debug:
                self.log.debug("Silent code shell reply: %s", reply)
        except Empty:
            self.log.error("Code took too long:\n %s", lines)

        # now empty the iopub channel (there is at least a "starting" message)
        while True:
            try:
                msg = kc.get_iopub_msg(timeout=0.1)
                if self.kernel_debug:
                    self.log.debug("Silent code iopub msg: %s", msg)
            except Empty:
                break

    def _get_kernel(self, engine):
        kernel_name = engine.kernel_name
        kernel_startup_lines = engine.startup_lines

        if kernel_name not in self._kernels:
            self.log.info("Starting a new kernel: %s" % kernel_name)
            kernelid = self._km.start_kernel(kernel_name=kernel_name)
            # km.list_kernel_ids()
            kn = self._km.get_kernel(kernelid)
            kc = kn.client()
            self._kernels[kernel_name] = kc
            # now initalize the channels
            kc.start_channels()
            kc.wait_for_ready()
            self._run_silently(kc, kernel_startup_lines)
            self.log.info("Executed kernel startup lines for engine '%s'.", engine.name)

        return self._kernels[kernel_name]

    def get_output_format(self, fmt_name, config=None):
        self._ensure_valid_output(fmt_name)
        fod = self._outputs.get(fmt_name).copy()
        # self.log.info("%s: %s", fmt_name, config)
        if not config:
            pass
        elif isinstance(config, dict):
            fod.update(**config)
        elif config == "default":
            # html_document: default
            pass
        else:
            self.log.error(
                "Unknown config for document '%s': '%s'. Ignored...", fmt_name, config
            )
        return fod

    def _knit(self, input, outputdir_name, final_format="html", config=None):
        """Internal function to aid testing"""

        parsed, metadata = self.parse_document(input)  # sets kpydoc.parsed and
        final_format = self.get_output_format(final_format, config=config)

        md_temp = TemporaryOutputDocument(
            fileoutputs=outputdir_name,
            export_config=final_format,
            log=self.log,
            parent=self,
        )

        # get the temporary md file
        self.convert(parsed, md_temp)

        return md_temp.content

    def render(self, filename, output=None):
        """
        Convert the filename to the given output format(s)
        """
        # Export each documents
        converted_docs = []

        # save here to change back after the conversation.
        orig_cwd = getcwd()
        needs_chdir = False

        # save original filename as pass in so we can include it in output
        input_filename = filename

        # expand $HOME and so on...
        filename = expand_path(filename)
        filename = os.path.abspath(filename)
        self.log.info("Converting %s..." % filename)

        basedir = os.path.dirname(filename)
        basename = os.path.splitext(os.path.basename(filename))[0]

        # no reason to continue past this point if we dont have
        # a valid file path, so check it here and provide a clear
        # failure message since this a common mistake
        if not os.path.exists(filename):
            raise OSError(
                f"File not found: {input_filename}\nExpanded path: {filename}"
            )

        # It's easier if we just change wd to the dir of the file
        if unicode_type(basedir) != getcwd():
            os.chdir(basedir)
            needs_chdir = True
            self.log.info("Changing to working dir: %s" % basedir)
            filename = os.path.basename(filename)

        outputdir_name = os.path.splitext(basename)[0] + "_files"

        # parse the input document
        parsed, metadata = self.parse_document(filename)

        # get the output formats
        # order: kwarg overwrites default overwrites document
        output_formats = [self._outputs[self.default_export_format]]
        if output is None:
            self.log.debug(
                "Converting to default output format [%s]!" % self.default_export_format
            )
        elif output == "all":
            outputs = metadata.get("output", None)
            # if nothing is specified, we keep the default
            if outputs is None:
                self.log.debug(
                    "Did not find any specified output formats: using only default!"
                )
            else:
                output_formats = []
                for fmt_name, config in iteritems(outputs):
                    fod = self.get_output_format(fmt_name, config)
                    output_formats.append(fod)
                self.log.debug(
                    "Converting to all specified output formats: %s"
                    % [fmt.name for fmt in output_formats]
                )
        else:
            self._ensure_valid_output(output)
            output_formats = [self._outputs[output]]

        for final_format in output_formats:
            self.log.info("Converting document %s to %s", filename, final_format.name)
            # TODO: build a proper way to specify final output...

            md_temp = TemporaryOutputDocument(
                fileoutputs=outputdir_name,
                export_config=final_format,
                log=self.log,
                parent=self,
            )

            # get the temporary md file
            self.convert(parsed, md_temp)
            if final_format.keep_md or self.keep_md:
                mdfilename = basename + "." + final_format.name + ".md"
                self.log.info("Saving the temporary markdown as '%s'." % mdfilename)
                # TODO: remove the first yaml metadata block and
                # put "#<title>\n<author>\n<date>" before the rest
                with codecs.open(mdfilename, "w+b", "UTF-8") as f:
                    f.write(md_temp.content)

            # convert the md file to the final filetype
            input_format = (
                "markdown"
                "+autolink_bare_uris"
                "+ascii_identifiers"
                "+tex_math_single_backslash-implicit_figures"
                "+fenced_code_attributes"
            )

            extra = [
                "--smart",  # typographically correct output (curly quotes, etc)
                "--email-obfuscation",
                "none",  # do not obfuscation email names with javascript
                "--self-contained",  # include img/scripts as data urls
                "--standalone",  # html with header + footer
                "--section-divs",
            ]

            outfilename = basename + "." + final_format.file_extension

            # exported is irrelevant, as we pass in a filename
            pandoc(
                source=md_temp.content,
                to=final_format.pandoc_export_format,
                format=input_format,
                extra_args=extra,
                outputfile=outfilename,
            )
            self.log.info("Written final output: %s" % outfilename)
            converted_docs.append(os.path.join(basedir, outfilename))
        if needs_chdir:
            os.chdir(orig_cwd)
        return converted_docs

    def _ensure_valid_output(self, fmt_name):
        if fmt_name in self._outputs:
            return
        raise KnitpyException("Format '%s' is not a valid output format!" % fmt_name)


class ExecutionContext(LoggingConfigurable):
    # These first are valid for the time of the existance of this contex
    output = Instance(
        klass=TemporaryOutputDocument,
        allow_none=True,
        config=False,
        help="current output document",
    )

    chunk_number = Integer(
        0, config=False, allow_none=False, help="current chunk number"
    )

    def _chunk_number_changed(self, name, old, new):
        if old != new:
            self.chunk_label = None

    enabled_documents = List([], config=False, help="Names for enabled documents.")

    # the following are valid for the time of one code execution
    chunk_label = Unicode(
        None, config=False, allow_none=True, help="current chunk label"
    )
    chunk_plot_number = Integer(
        0, config=False, allow_none=False, help="current plot number in this chunk"
    )

    def _chunk_label_changed(self, name, old, new):
        if old != new:
            self.chunk_plot_number = 0

    echo = Bool(
        True,
        config=False,
        help="If False, pymdknit will not display the code in the code "
        "chunk above it's results in the final document.",
    )

    results = CaselessStrEnum(
        default_value="markup",
        values=["markup", "hide", "hold", "asis"],
        allow_none=False,
        config=False,
        help="If 'hide', pymdknit will not display the codes results in the "
        "final document. If 'hold', pymdknit will delay displaying all  "
        "output pieces until the end of the chunk. If 'asis', "
        "pymdknit will pass through results without reformatting them "
        "(useful if results return raw HTML, etc.)",
    )

    include = Bool(
        True,
        config=False,
        help="If False, pymdknit will will run the chunk but not "
        "include the chunk in the final document.",
    )

    comment = Unicode(
        default_value="##",
        config=False,
        allow_none=True,
        help="Prefix which is added to all (text) output; None or empty string will "
        "result in no prefix",
    )

    mode = CaselessStrEnum(
        default_value=None,
        values=["inline", "block"],
        allow_none=True,
        config=False,
        help="current mode: inline or block",
    )

    engine = Instance(
        klass=BaseKnitpyEngine, allow_none=True, config=False, help="current engine"
    )

    def __init__(self, output, **kwargs):
        super().__init__(**kwargs)
        self.output = output
        output.context = self

    def execution_started(self):
        self.chunk_number += 1

    def execution_finished(self):
        self.output.flush()
        reset_needed = [
            "engine",
            "modechunk_label",
            "comment",
            "include",
            "echo",
            "include",
            "results",
        ]
        for name in self.trait_names():
            if name in reset_needed:
                try:
                    self.traits()[name].instance_init(self)
                except AttributeError:
                    # older ipython versions
                    self.traits()[name].set_default_value(self)
</file>

<file path="pymdknit/pymdknitapp.py">
#!/usr/bin/env python
"""
pymdknit - knitting python flavoured markdown files
"""

# Copyright (c) Jan Schulz <jasc@gmx.net>
# Copyright (c) IPython Development Team.
# Distributed under the terms of the Modified BSD License.


# -----------------------------------------------------------------------------
# Imports
# -----------------------------------------------------------------------------

import glob
import logging
import sys

# TODO: fix IPython useage...
from jupyter_core.application import JupyterApp, base_aliases, base_flags
from traitlets import Bool, CaselessStrEnum, List, Unicode
from traitlets.config import catch_config_error

from .documents import TemporaryOutputDocument
from .pymdknit import (DEFAULT_OUTPUT_FORMAT_NAME, VALID_OUTPUT_FORMAT_NAMES,
                       ParseException, PyMdKnit)
from .utils import get_by_name

# -----------------------------------------------------------------------------
# Main application
# -----------------------------------------------------------------------------

knitpy_aliases = {}
knitpy_aliases.update(base_aliases)
knitpy_aliases.update(
    {
        "to": "PyMdKnitApp.export_format",
        # TODO: implement log-to-file (form parallel apps)
        "log-to-file": "PyMdKnitApp.log_to_file",
        "keep-md": "PyMdKnit.keep_md",
        "kernel-debug": "PyMdKnit.kernel_debug",
        "timeout": "PyMdKnit.timeout",
        "output-debug": "TemporaryOutputDocument.output_debug",
    }
)

knitpy_flags = {}
knitpy_flags.update(base_flags)
knitpy_flags.update(
    {
        "log-to-file": (
            {"PyMdKnitApp": {"log_to_file": True}},
            "send log output to a file",
        ),
        "keep-md": ({"PyMdKnit": {"keep_md": True}}, "keep temporary markdown files"),
        "kernel-debug": (
            {
                "PyMdKnit": {"kernel_debug": True},
                "PyMdKnitApp": {"log_level": logging.DEBUG},
            },
            "send kernel messages to debug log (implies log-level=DEBUG)",
        ),
        "output-debug": (
            {
                "TemporaryOutputDocument": {"output_debug": True},
                "PyMdKnitApp": {"log_level": logging.DEBUG},
            },
            "send output to debug log (implies log-level=DEBUG)",
        ),
    }
)


class PyMdKnitApp(JupyterApp):
    """Application used to convert from markdown file type (``*.pymd``)"""

    name = "pymdknit"
    version = Unicode("0.1")
    aliases = knitpy_aliases
    flags = knitpy_flags

    def _log_level_default(self):
        return logging.INFO

    def _classes_default(self):
        classes = [PyMdKnitApp, PyMdKnit, TemporaryOutputDocument, ProfileDir]
        # TODO: engines should be added here
        return classes

    description = Unicode(
        """This application is used to convert pymd documents (*.pymd)
        to various other formats.

        Codeblocks and inline code are executed via IPython kernels and the results
        are inserted into the document. Documents should follow rmarkdown syntax
        (http://rmarkdown.rstudio.com/), substituting 'python' for 'r' if python
        code should be executed.

        The commandline interface should be compatible to knitr.

        Like these R packages, pymdknit uses pandoc to do any file type conversion
        (md -> html|latex|...).

        ONLY SOME FEATURES OF knitr OR rmarkdown ARE YET SUPPORTED...
        """
    )

    examples = Unicode("""
        The simplest way to use pymdknit is

        > pymdknit mydocument.pymd

        which will convert mydocument.pymd to the default format (probably HTML).
        """)

    # Other configurable variables
    # '--to' ends up here
    export_format = CaselessStrEnum(
        VALID_OUTPUT_FORMAT_NAMES + ["all"],
        default_value=DEFAULT_OUTPUT_FORMAT_NAME,
        config=True,
        help="""The export format to be used.""",
    )

    # This is a workaround for https://github.com/ipython/ipython/issues/8025
    # a value of "all" is converted to the function `all` during commandline parsing, which
    # raises if that is set as `export_format`. So on config change, first change it back and
    # then call the original _config_changed(), which puts the config values to the traits
    def _config_changed(self, name, old, new):
        if get_by_name(new, "PyMdKnitApp.export_format", na=None) is all:
            new.KnitpyApp.export_format = "all"
        super()._config_changed(name, old, new)

    documents = List(
        [],
        config=True,
        help="""List of documents to convert.
                 Wildcards are supported.
                 Filenames passed positionally will be added to the list.
                 """,
    )

    keep_md = Bool(
        False, config=True, help="""Whether to keep the temporary md files"""
    )

    log_to_file = Bool(False, config=True, help="""Whether to send the log to a file""")

    @catch_config_error
    def initialize(self, argv=None):
        super().initialize(argv)  # sets the crash handler
        self.init_documents()

    def init_documents(self):
        """Construct the list of documents.
        If documents are passed on the command-line,
        they override documents specified in config files.
        Glob each document to replace document patterns with filenames.
        """

        # Specifying documents on the command-line overrides (rather than adds)
        # the documents list
        if self.extra_args:
            patterns = self.extra_args
        else:
            patterns = self.documents

        # Use glob to replace all the documents patterns with filenames.
        filenames = []
        for pattern in patterns:
            # Use glob to find matching filenames.  Allow the user to convert
            # documents without having to type the extension.
            globbed_files = glob.glob(pattern)
            globbed_files.extend(glob.glob(pattern + ".pymd"))
            if not globbed_files:
                self.log.warn("pattern %r matched no files", pattern)

            for filename in globbed_files:
                if filename not in filenames:
                    filenames.append(filename)
        self.documents = filenames

    def start(self):
        """
        Ran after initialization completed
        """
        super().start()
        self.convert_documents()

    def convert_documents(self):
        """
        Convert the documents in the self.document traitlet
        """
        # Export each documents
        conversion_success = 0

        kp = PyMdKnit(log=self.log, parent=self)

        for document_filename in self.documents:
            try:
                outfilenames = kp.render(document_filename, output=self.export_format)
            except ParseException as pe:
                self.log.error(str(pe))
                self.log.error(
                    "Error while converting '%s'. Aborting...", document_filename
                )
                exit(1)

            except Exception:
                self.log.error(
                    "Error while converting '%s'", document_filename, exc_info=True
                )
                exit(1)

            # Todo: add a config value... auto-open
            if self.export_format in ["html", "htm"]:
                import webbrowser

                webbrowser.open(outfilenames[0])
            conversion_success += 1

        # If nothing was converted successfully, help the user.
        if conversion_success == 0:
            self.print_help()
            sys.exit(-1)


# redefine the error message on crashes
# The price we pay for reusing the BaseIPythonApplication
_knitpy_lite_message_template = """
If you suspect this is an pymdknit bug, please report it at:
    https://github.com/janschulz/pymdknit/issues
or send an email to the mailing list at {email}

Extra-detailed tracebacks for bug-reporting purposes can be enabled via:
    {config}Application.verbose_crash=True
"""
import IPython.core.crashhandler as ch

ch._lite_message_template = _knitpy_lite_message_template


# -----------------------------------------------------------------------------
# Main entry point
# -----------------------------------------------------------------------------

launch_new_instance = PyMdKnitApp.launch_instance

if __name__ == "__main__":
    launch_new_instance()
</file>

<file path="pymdknit/utils.py">
__author__ = "jschulz"

from .py3compat import string_types


class _NA_DEFAULT_CLASS:
    pass


_NA_DEFAULT = _NA_DEFAULT_CLASS()


def get_by_name(dict_like, name, na="<n/a"):
    res = dict_like
    for part in name.split("."):
        try:
            res = res.get(part, _NA_DEFAULT)
        except:
            return na
        if res is _NA_DEFAULT:
            return na
    return res


def filter_for_debug(msg, names=None):
    if names is None:
        names = ["msg_type", "content.data"]

    # example...
    {
        "parent_header": {
            "username": "username",
            "version": "5.0",
            "msg_type": "execute_request",
            "msg_id": "4383f7f6-0b2f-4ad8-80c8-4f790e3bf389",
            "session": "6925e9c2-29f1-44a6-9af1-8b375bc996cc",
            "date": datetime.datetime(2015, 2, 26, 1, 44, 45, 925000),
        },
        "msg_type": "execute_reply",
        "msg_id": "8b22db97-9106-40cb-9e23-eda214bfa499",
        "content": {
            "status": "ok",
            "execution_count": 2,
            "user_expressions": {},
            "payload": [],
        },
        "header": {
            "username": "username",
            "version": "5.0",
            "msg_type": "execute_reply",
            "msg_id": "8b22db97-9106-40cb-9e23-eda214bfa499",
            "session": "45cc1a4f-dd43-4067-838d-412e2e16bb7d",
            "date": datetime.datetime(2015, 2, 26, 1, 44, 45, 936000),
        },
        "buffers": [],
        "metadata": {
            "dependencies_met": True,
            "engine": "6364f52f-1366-4e5c-999e-326736541ff1",
            "status": "ok",
            "started": "2015-02-26T01:44:45.926000",
        },
    }
    ret = {}
    for name in names:
        ret[name] = get_by_name(msg, name)
    return ret


def _plain_text(content):
    data = content.get("data")
    if data is not None:
        return data.get("text/plain", "")
    else:
        return ""


def _code(content):
    return content.get("code", "")


def is_iterable(obj):
    "return true if *obj* is iterable"
    try:
        iter(obj)
    except TypeError:
        return False
    return True


def is_string(obj):
    return isinstance(obj, string_types)


import re

from traitlets import TraitType


class CRegExpMultiline(TraitType):
    """A casting compiled regular expression trait.

    Accepts both strings and compiled regular expressions. The resulting
    attribute will be a compiled regular expression."""

    info_text = "a regular expression"

    def validate(self, obj, value):
        try:
            return re.compile(value, re.MULTILINE)
        except:
            self.error(obj, value)
</file>

<file path="conda_env_dev_27.yml">
name: knitpy_27
dependencies:
- python=2.7
- jupyter_client>=4
- jupyter_core>=4
- traitlets
- ipykernel>=4
- pyyaml>=3.10
- pyzmq>=14.0
- pandas
- matplotlib
- nose>=1.3
- pip>=7.1
- pip:
  - pypandoc
  - sphinx
  - tabulate
</file>

<file path="conda_env_dev_35.yml">
name: knitpy_35
dependencies:
- python=3.5
- jupyter_client>=4
- jupyter_core>=4
- traitlets
- ipykernel>=4
- pyyaml>=3.10
- pyzmq>=14.0
- pandas
- matplotlib
- nose>=1.3
- pip>=7.1
- pip:
  - pypandoc
  - sphinx
  - tabulate
</file>

<file path="pymdknit.py">
__author__ = "jschulz"

from pymdknit.pymdknitapp import PyMdKnitApp

if __name__ == "__main__":
    PyMdKnitApp.launch_instance()
</file>

<file path="LICENSE.rst">
=============================
 The knitpy licensing terms
=============================

PyMdKnit is licensed under the terms of the Modified BSD License (also known as
New or Revised or 3-Clause BSD), as follows:

- Copyright (c) 2015, Jan Schulz <jasc@gmx.net>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the knitpy project nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</file>

<file path="test_singleconversion.py">
#!/usr/bin/env python

## Running all output tests in the debugger is a pain, so use this to run only one

# Copyright (c) Jan Schulz <jasc@gmx.net>
# Distributed under the terms of the Modified BSD License.

import os

from pymdknit.tests import AbstractOutputTestCase


class SingleOutputTestCase(AbstractOutputTestCase):
    def test_single_output(self):
        testname = "pymdknit/tests/chunk_options/comment.pymd"

        input_file = os.path.join(testname)
        output_file = input_file[:-4] + "md"
        self._output_test(input_file, output_file)


if __name__ == "__main__":
    import nose

    nose.runmodule(
        argv=[__file__, "-vvs", "-x", "--pdb", "--pdb-failure"],
        # '--with-coverage', '--cover-package=pandas.core']
        exit=False,
    )
</file>

<file path=".travis.yml">
# http://travis-ci.org/#!/ipython/ipython
language: python

python:
    - 3.4
    - 2.7

env:
  global:
    - PATH=$TRAVIS_BUILD_DIR/pandoc:$PATH

install:
  # We do this conditionally because it saves us some downloading if the version is
  # the same.
  - if [[ "$TRAVIS_PYTHON_VERSION" == "2.7" ]]; then
      wget http://repo.continuum.io/miniconda/Miniconda-latest-Linux-x86_64.sh -O miniconda.sh;
    else
      wget http://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh;
    fi
  - bash miniconda.sh -b -p $HOME/miniconda
  - export PATH="$HOME/miniconda/bin:$PATH"
  - hash -r
  - conda config --set always_yes yes --set changeps1 no
  - conda update -q conda

  # install our packages
  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION pip pyyaml matplotlib jupyter_client jupyter_core traitlets ipykernel  nose pyzmq
  - source activate test-environment

  # pandoc...
  - 'wget https://7de4dfdec62155b49b44-d726a73613a1989d29b147f20996e7c1.ssl.cf2.rackcdn.com/pandoc-1.12.3-linux-debian-x86_64.zip && unzip pandoc-1.12.3-linux-debian-x86_64.zip;'
  - export PATH=$TRAVIS_BUILD_DIR/pandoc:$PATH
  - pip install pypandoc

  # Useful for debugging any issues with conda
  - conda info -a
  - conda list

  - python setup.py install

script:
  - nosetests knitpy
</file>

<file path=".gitignore">
# at first project specific files
# generated conversion failures
*.received
# unfinshed conversion tests
*.off

# kernel files, which wer enot removed after a crash
kernel*.json

# manually generated pymdknit config file
knitpy_config.py

# ipython checkpoints/ backup copies
.ipynb_checkpoints/

# now more or less everything which generally doe snot belong to a repo
*.py[cod]
*.pyc

# C extensions
*.so

# Packages
*.egg
*.egg-info
dist
build
eggs
parts
bin
var
sdist
develop-eggs
.installed.cfg
lib
lib64

# generated docs
docs/_static/
docs/generated/

# Installer logs
pip-log.txt

# Unit test / coverage reports
.coverage
.tox
nosetests.xml

# Translations
*.mo

# Mr Developer
.mr.developer.cfg
.project
.pydevproject

#pycharm
.idea/

*.swp

# Testing
tmp
rmd/
*.ipynb

# examples which do not need to be in the repo (html should be..)
examples/knitpy_overview_files/figure-docx/
examples/knitpy_overview_files/figure-pdf/
examples/knitpy_overview_files/figure-tex/
examples/knitpy_overview.tex
</file>

<file path="examples/knitpy_overview.html_document.md">
---
title: "knitpy: dynamic report generation with python"
author: "Jan Schulz"
date: "12.03.2015"
output:
  pdf_document: default
  word_document: default
  html_document:
    keep_md: yes
---

This is a port of knitr (http://yihui.name/knitr/) and rmarkdown 
(http://rmarkdown.rstudio.com/) to python.

For a complete description of the code format see http://rmarkdown.rstudio.com/ and replace
`{r...}` by `{python ...}` and of course use python code blocks...

## Examples

Here are some examples:

```python
print("Execute some code chunk and show the result")
```

```
## Execute some code chunk and show the result
```

Codechunks which contain lines without output (e.g. assign the result or comments) will
be shown in the same code block:

```python
# A comment
text = "All code in the same code block until some output is produced..."
more_text = "...and some more."
print(text)
```

```
## All code in the same code block until some output is produced...
```

```python
print(more_text)
```

```
## ...and some more.
```

### Code chunk arguments

You can use different arguments in the codechunk declaration. Using `echo=False` will not show
the code but only the result.

```
## Only the output will be visible as `echo=False`
```

The next paragraphs explores the code chunk argument `results`. 

If 'hide', knitpy will not display the code's results in the final document. If 'hold', knitpy
will delay displaying all output pieces until the end of the chunk. If 'asis', knitpy will pass
through results without reformatting them (useful if results return raw HTML, etc.)

`results='hold'` is not yet implemented.

```python
print("Only the input is displayed, not the output")
```

```
## This is formatted as markdown:
## **This text** will be bold...
```

**This text** will be bold...

**Note**: with python code it is recommended to use the IPython/Jupyter display system and an 
appropriate wrapper (see below) to display such output and not `results="asis"`. This makes it 
possible to convert such output if the output can't be included in the final format.

You can also not show codeblocks at all, but they will be run (not included codeblock sets
`have_run = True`):


```python
if have_run == True:
    print("'have_run==True': ran the codeblock before this one.")
```

```
## 'have_run==True': ran the codeblock before this one.
```

Using `eval=False`, one can prevent the evaluation of the codechunk

```python
x = 1
```

```python
x += 1 # this is not executed as eval is False
```

```python
x # still 1
```

```
## 1
```

To remove/hide a codechunk completely, i.e. neither execute it nor show the code, you can use both `eval=False, include=False`: nothing will be
shown between this text ...

```python
x += 1 # this is not executed and not even shown
```

... and this text here!

The prefix in front of text output (per default `##`) can be changed via the `comment` chunk
option to a different string or completely removed by setting it to a empty string `""`or None:

```python
print("Text output")
```

```
# result: Text output
```

```python
print("Text output")
```

```
Text output
```

### Inline code

You can also include code inline: "m=2" (expected: "m=2") 

### IPython / Jupyter display framework

The display framework is also supported.

Plots will be included as images and included in the document. The filename of the 
plot is derived from the chunk label ("sinus" in this case). The code is not 
shown in this case (`echo=False`).


![](knitpy_overview_files/figure-html/sinus-0.png)

If a html or similar thing is displayed via the IPython display framework, it will be 
included 'as is', meaning that apart from `text/plain`-only output, everything else 
will be included without marking it up as output. PyMdKnit automagically tries to include only
formats which are understood by pandoc and the final output format (in some case converting the
format to one which the final output can handle).

```python
from IPython.core.display import display, HTML
display(HTML("<strong>strong text</strong>"))
```


<strong>strong text</strong>

It even handles `pandas.DataFrames` (be aware that not all formatting can be converted into all
output formats):

```python
import pandas as pd
pd.set_option("display.width", 200) 
s = """This is longer text"""
df = pd.DataFrame({"a":[1,2,3,4,5],"b":[s,"b","c",s,"e"]})
df
```


<div style="max-height:1000px;max-width:1500px;overflow:auto;"><table border="1" class="dataframe"><thead><tr style="text-align: right;"><th></th><th>a</th><th>b</th></tr></thead><tbody><tr><th>0</th><td> 1</td><td> This is longer text</td></tr><tr><th>1</th><td> 2</td><td> b</td></tr><tr><th>2</th><td> 3</td><td> c</td></tr><tr><th>3</th><td> 4</td><td> This is longer text</td></tr><tr><th>4</th><td> 5</td><td> e</td></tr></tbody></table></div>

`pandas.DataFrame` can be represented as `text/plain` or `text/html`, but will default to the html
 version. To force plain text, use either `print(df)` or set the right `pandas` option:

```python
pd.set_option("display.notebook_repr_html", False)
df
```

```
##    a                    b
## 0  1  This is longer text
## 1  2                    b
## 2  3                    c
## 3  4  This is longer text
## 4  5                    e
```

```python
# set back the display
pd.set_option("display.notebook_repr_html", True)
```

You can also use package like [tabulate](https://bitbucket.org/astanin/python-tabulate)
together with `results="asis"` or by wrapping it with the appropriate display class:

```python
from tabulate import tabulate
from IPython.core.display import Markdown
# either print and use `results="asis"`
print(tabulate(df, list(df.columns), tablefmt="simple"))
```

    a    b
--  ---  -------------------
 0  1    This is longer text
 1  2    b
 2  3    c
 3  4    This is longer text
 4  5    e

```python
# or use the IPython display framework to publish markdown
Markdown(tabulate(df, list(df.columns), tablefmt="simple"))
```


    a    b
--  ---  -------------------
 0  1    This is longer text
 1  2    b
 2  3    c
 3  4    This is longer text
 4  5    e

Note that the second version (wrapping it in `Markdown`) is preferred, as this marks the output 
with the right mimetype and therefore can be converted---if that's needed---to something which 
the output format understands!

Unfortunately, html tables have to be tweaked for the final output format as e.g. too width
tables spill over the page margin in PDF.

### Error handling

Errors in code are shown with a bold error text:

```python
import sys
print(sys.not_available)
```

**ERROR**: AttributeError: 'module' object has no attribute 'not_available'

```
AttributeError                            Traceback (most recent call last)
<ipython-input-37-a5971246c0f7> in <module>()
----> 1 print(sys.not_available)

AttributeError: 'module' object has no attribute 'not_available'
```


```python
for x in []:
print("No indention...")
```

**ERROR**: Code invalid
</file>

<file path="examples/knitpy_overview.pymd">
---
title: "knitpy: dynamic report generation with python"
author: "Jan Schulz"
date: "12.03.2015"
output:
  pdf_document: default
  word_document: default
  html_document:
    keep_md: yes
---

This is a port of knitr (http://yihui.name/knitr/) and rmarkdown 
(http://rmarkdown.rstudio.com/) to python.

For a complete description of the code format see http://rmarkdown.rstudio.com/ and replace
`{r...}` by `{python ...}` and of course use python code blocks...

## Examples

Here are some examples:

```{python}
print("Execute some code chunk and show the result")
```

Codechunks which contain lines without output (e.g. assign the result or comments) will
be shown in the same code block:

```{python}
# A comment
text = "All code in the same code block until some output is produced..."
more_text = "...and some more."
print(text)
print(more_text)
```

### Code chunk arguments

You can use different arguments in the codechunk declaration. Using `echo=False` will not show
the code but only the result.

```{python echo=False}
print("Only the output will be visible as `echo=False`")
```

The next paragraphs explores the code chunk argument `results`. 

If 'hide', knitpy will not display the code's results in the final document. If 'hold', knitpy
will delay displaying all output pieces until the end of the chunk. If 'asis', knitpy will pass
through results without reformatting them (useful if results return raw HTML, etc.)

`results='hold'` is not yet implemented.

```{python results="hide"}
print("Only the input is displayed, not the output")
```

```{python results="markup", echo=False}
print("This is formatted as markdown:\n**This text** will be bold...")
```

```{python results="asis", echo=False}
print("**This text** will be bold...")
```

**Note**: with python code it is recommended to use the IPython/Jupyter display system and an 
appropriate wrapper (see below) to display such output and not `results="asis"`. This makes it 
possible to convert such output if the output can't be included in the final format.

You can also not show codeblocks at all, but they will be run (not included codeblock sets
`have_run = True`):

```{python include=False}
have_run = True
print("This will not be shown, as include is False")
```

```{python include=True}
if have_run == True:
    print("'have_run==True': ran the codeblock before this one.")
```

Using `eval=False`, one can prevent the evaluation of the codechunk

```{python}
x = 1
```

```{python eval=False}
x += 1 # this is not executed as eval is False
```

```{python}
x # still 1
```


To remove/hide a codechunk completely, i.e. neither execute it nor show the code, you can use both `eval=False, include=False`: nothing will be
shown between this text ...

```{python eval=False, include=False}
x += 1 # this is not executed and not even shown
```

... and this text here!

The prefix in front of text output (per default `##`) can be changed via the `comment` chunk
option to a different string or completely removed by setting it to a empty string `""`or None:

```{python comment="# result:"}
print("Text output")
```

```{python comment=""}
print("Text output")
```

### Inline code

You can also include code inline: "m=`python 1+1`" (expected: "m=2") 

### IPython / Jupyter display framework

The display framework is also supported.

Plots will be included as images and included in the document. The filename of the 
plot is derived from the chunk label ("sinus" in this case). The code is not 
shown in this case (`echo=False`).

```{python sinus, echo=False}
# As this all produces no output, it should go into the same input section...
import numpy as np
import matplotlib.pyplot as plt
y = np.linspace(2, 10)
line, = plt.plot(y, np.sin(y))
```

If a html or similar thing is displayed via the IPython display framework, it will be 
included 'as is', meaning that apart from `text/plain`-only output, everything else 
will be included without marking it up as output. PyMdKnit automagically tries to include only
formats which are understood by pandoc and the final output format (in some case converting the
format to one which the final output can handle).

```{python engine="python"}
from IPython.core.display import display, HTML
display(HTML("<strong>strong text</strong>"))
```

It even handles `pandas.DataFrames` (be aware that not all formatting can be converted into all
output formats):

```{python}
import pandas as pd
pd.set_option("display.width", 200) 
s = """This is longer text"""
df = pd.DataFrame({"a":[1,2,3,4,5],"b":[s,"b","c",s,"e"]})
df
```

`pandas.DataFrame` can be represented as `text/plain` or `text/html`, but will default to the html
 version. To force plain text, use either `print(df)` or set the right `pandas` option:

```{python}
pd.set_option("display.notebook_repr_html", False)
df
# set back the display
pd.set_option("display.notebook_repr_html", True)
```

You can also use package like [tabulate](https://bitbucket.org/astanin/python-tabulate)
together with `results="asis"` or by wrapping it with the appropriate display class:

```{python results="asis"}
from tabulate import tabulate
from IPython.core.display import Markdown
# either print and use `results="asis"`
print(tabulate(df, list(df.columns), tablefmt="simple"))
# or use the IPython display framework to publish markdown
Markdown(tabulate(df, list(df.columns), tablefmt="simple"))
```

Note that the second version (wrapping it in `Markdown`) is preferred, as this marks the output 
with the right mimetype and therefore can be converted---if that's needed---to something which 
the output format understands!

Unfortunately, html tables have to be tweaked for the final output format as e.g. too width
tables spill over the page margin in PDF.

### Error handling

Errors in code are shown with a bold error text:

```{python}
import sys
print(sys.not_available)
```

```{python}
for x in []:
print("No indention...")
```
</file>

<file path="examples/knitpy_overview.html">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Jan Schulz" />
  <title>knitpy: dynamic report generation with python</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">knitpy: dynamic report generation with python</h1>
<h2 class="author">Jan Schulz</h2>
<h3 class="date">12.03.2015</h3>
</div>
<p>This is a port of knitr (<a href="http://yihui.name/knitr/" class="uri">http://yihui.name/knitr/</a>) and rmarkdown (<a href="http://rmarkdown.rstudio.com/" class="uri">http://rmarkdown.rstudio.com/</a>) to python.</p>
<p>For a complete description of the code format see <a href="http://rmarkdown.rstudio.com/" class="uri">http://rmarkdown.rstudio.com/</a> and replace <code>{r...}</code> by <code>{python ...}</code> and of course use python code blocks</p>
<div id="examples" class="section level2">
<h2>Examples</h2>
<p>Here are some examples:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="dt">print</span>(<span class="st">&quot;Execute some code chunk and show the result&quot;</span>)</code></pre>
<pre><code>## Execute some code chunk and show the result</code></pre>
<p>Codechunks which contain lines without output (e.g.assign the result or comments) will be shown in the same code block:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># A comment</span>
text = <span class="st">&quot;All code in the same code block until some output is produced...&quot;</span>
more_text = <span class="st">&quot;...and some more.&quot;</span>
<span class="dt">print</span>(text)</code></pre>
<pre><code>## All code in the same code block until some output is produced...</code></pre>
<pre class="sourceCode python"><code class="sourceCode python"><span class="dt">print</span>(more_text)</code></pre>
<pre><code>## ...and some more.</code></pre>
<div id="code-chunk-arguments" class="section level3">
<h3>Code chunk arguments</h3>
<p>You can use different arguments in the codechunk declaration. Using <code>echo=False</code> will not show the code but only the result.</p>
<pre><code>## Only the output will be visible as `echo=False`</code></pre>
<p>The next paragraphs explores the code chunk argument <code>results</code>.</p>
<p>If hide, knitpy will not display the codes results in the final document. If hold, knitpy will delay displaying all output pieces until the end of the chunk. If asis, knitpy will pass through results without reformatting them (useful if results return raw HTML, etc.)</p>
<p><code>results='hold'</code> is not yet implemented.</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="dt">print</span>(<span class="st">&quot;Only the input is displayed, not the output&quot;</span>)</code></pre>
<pre><code>## This is formatted as markdown:
## **This text** will be bold...</code></pre>
<p><strong>This text</strong> will be bold</p>
<p><strong>Note</strong>: with python code it is recommended to use the IPython/Jupyter display system and an appropriate wrapper (see below) to display such output and not <code>results=&quot;asis&quot;</code>. This makes it possible to convert such output if the output cant be included in the final format.</p>
<p>You can also not show codeblocks at all, but they will be run (not included codeblock sets <code>have_run = True</code>):</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">if</span> have_run == <span class="ot">True</span>:
    <span class="dt">print</span>(<span class="st">&quot;'have_run==True': ran the codeblock before this one.&quot;</span>)</code></pre>
<pre><code>## 'have_run==True': ran the codeblock before this one.</code></pre>
<p>Using <code>eval=False</code>, one can prevent the evaluation of the codechunk</p>
<pre class="sourceCode python"><code class="sourceCode python">x = <span class="dv">1</span></code></pre>
<pre class="sourceCode python"><code class="sourceCode python">x += <span class="dv">1</span> <span class="co"># this is not executed as eval is False</span></code></pre>
<pre class="sourceCode python"><code class="sourceCode python">x <span class="co"># still 1</span></code></pre>
<pre><code>## 1</code></pre>
<p>To remove/hide a codechunk completely, i.e.neither execute it nor show the code, you can use both <code>eval=False, include=False</code>: nothing will be shown between this text </p>
<pre class="sourceCode python"><code class="sourceCode python">x += <span class="dv">1</span> <span class="co"># this is not executed and not even shown</span></code></pre>
<p> and this text here!</p>
<p>The prefix in front of text output (per default <code>##</code>) can be changed via the <code>comment</code> chunk option to a different string or completely removed by setting it to a empty string <code>&quot;&quot;</code>or None:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="dt">print</span>(<span class="st">&quot;Text output&quot;</span>)</code></pre>
<pre><code># result: Text output</code></pre>
<pre class="sourceCode python"><code class="sourceCode python"><span class="dt">print</span>(<span class="st">&quot;Text output&quot;</span>)</code></pre>
<pre><code>Text output</code></pre>
</div>
<div id="inline-code" class="section level3">
<h3>Inline code</h3>
<p>You can also include code inline: m=2 (expected: m=2)</p>
</div>
<div id="ipython-jupyter-display-framework" class="section level3">
<h3>IPython / Jupyter display framework</h3>
<p>The display framework is also supported.</p>
<p>Plots will be included as images and included in the document. The filename of the plot is derived from the chunk label (sinus in this case). The code is not shown in this case (<code>echo=False</code>).</p>
<p><img src="data:image/png;base64,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" /></p>
<p>If a html or similar thing is displayed via the IPython display framework, it will be included as is, meaning that apart from <code>text/plain</code>-only output, everything else will be included without marking it up as output. PyMdKnit automagically tries to include only formats which are understood by pandoc and the final output format (in some case converting the format to one which the final output can handle).</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> IPython.core.display <span class="ch">import</span> display, HTML
display(HTML(<span class="st">&quot;&lt;strong&gt;strong text&lt;/strong&gt;&quot;</span>))</code></pre>
<p><strong>strong text</strong></p>
<p>It even handles <code>pandas.DataFrames</code> (be aware that not all formatting can be converted into all output formats):</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> pandas <span class="ch">as</span> pd
pd.set_option(<span class="st">&quot;display.width&quot;</span>, <span class="dv">200</span>) 
s = <span class="st">&quot;&quot;&quot;This is longer text&quot;&quot;&quot;</span>
df = pd.DataFrame({<span class="st">&quot;a&quot;</span>:[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>],<span class="st">&quot;b&quot;</span>:[s,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>,s,<span class="st">&quot;e&quot;</span>]})
df</code></pre>
<div style="max-height:1000px;max-width:1500px;overflow:auto;">
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th>
</th>
<th>
a
</th>
<th>
b
</th>
</tr>
</thead>
<tbody>
<tr>
<th>
0
</th>
<td>
1
</td>
<td>
This is longer text
</td>
</tr>
<tr>
<th>
1
</th>
<td>
2
</td>
<td>
b
</td>
</tr>
<tr>
<th>
2
</th>
<td>
3
</td>
<td>
c
</td>
</tr>
<tr>
<th>
3
</th>
<td>
4
</td>
<td>
This is longer text
</td>
</tr>
<tr>
<th>
4
</th>
<td>
5
</td>
<td>
e
</td>
</tr>
</tbody>
</table>
</div>
<p><code>pandas.DataFrame</code> can be represented as <code>text/plain</code> or <code>text/html</code>, but will default to the html version. To force plain text, use either <code>print(df)</code> or set the right <code>pandas</code> option:</p>
<pre class="sourceCode python"><code class="sourceCode python">pd.set_option(<span class="st">&quot;display.notebook_repr_html&quot;</span>, <span class="ot">False</span>)
df</code></pre>
<pre><code>##    a                    b
## 0  1  This is longer text
## 1  2                    b
## 2  3                    c
## 3  4  This is longer text
## 4  5                    e</code></pre>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># set back the display</span>
pd.set_option(<span class="st">&quot;display.notebook_repr_html&quot;</span>, <span class="ot">True</span>)</code></pre>
<p>You can also use package like <a href="https://bitbucket.org/astanin/python-tabulate">tabulate</a> together with <code>results=&quot;asis&quot;</code> or by wrapping it with the appropriate display class:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> tabulate <span class="ch">import</span> tabulate
<span class="ch">from</span> IPython.core.display <span class="ch">import</span> Markdown
<span class="co"># either print and use `results=&quot;asis&quot;`</span>
<span class="dt">print</span>(tabulate(df, <span class="dt">list</span>(df.columns), tablefmt=<span class="st">&quot;simple&quot;</span>))</code></pre>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">a</th>
<th align="left">b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">1</td>
<td align="left">This is longer text</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">2</td>
<td align="left">b</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">3</td>
<td align="left">c</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">4</td>
<td align="left">This is longer text</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">5</td>
<td align="left">e</td>
</tr>
</tbody>
</table>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># or use the IPython display framework to publish markdown</span>
Markdown(tabulate(df, <span class="dt">list</span>(df.columns), tablefmt=<span class="st">&quot;simple&quot;</span>))</code></pre>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">a</th>
<th align="left">b</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">1</td>
<td align="left">This is longer text</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">2</td>
<td align="left">b</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">3</td>
<td align="left">c</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">4</td>
<td align="left">This is longer text</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">5</td>
<td align="left">e</td>
</tr>
</tbody>
</table>
<p>Note that the second version (wrapping it in <code>Markdown</code>) is preferred, as this marks the output with the right mimetype and therefore can be convertedif thats neededto something which the output format understands!</p>
<p>Unfortunately, html tables have to be tweaked for the final output format as e.g.too width tables spill over the page margin in PDF.</p>
</div>
<div id="error-handling" class="section level3">
<h3>Error handling</h3>
<p>Errors in code are shown with a bold error text:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">import</span> sys
<span class="dt">print</span>(sys.not_available)</code></pre>
<p><strong>ERROR</strong>: AttributeError: module object has no attribute not_available</p>
<pre><code>AttributeError                            Traceback (most recent call last)
&lt;ipython-input-37-a5971246c0f7&gt; in &lt;module&gt;()
----&gt; 1 print(sys.not_available)

AttributeError: 'module' object has no attribute 'not_available'</code></pre>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">for</span> x in []:
<span class="dt">print</span>(<span class="st">&quot;No indention...&quot;</span>)</code></pre>
<p><strong>ERROR</strong>: Code invalid</p>
</div>
</div>
</body>
</html>
</file>

<file path="setup.py">
from setuptools import setup

try:
    from pypandoc import convert

    long_desc = convert(open("README.md").read(), to="rst", format="markdown")
except:
    long_desc = (
        "pymdknit - Elegant, flexible and fast dynamic report generation with python"
    )

setup(
    name="pymdknit",
    version="0.1.1",
    description="Elegant, flexible and fast dynamic report generation with python",
    long_description=long_desc,
    author="Jan Schulz",
    author_email="jasc@gmx.net",
    maintainer="Adam Twardoch",
    maintainer_email="adam+github@twardoch.com",
    url="https://github.com/janschulz/pymdknit/issues",
    license="BSD",
    classifiers=[
        "Development Status :: 4 - Beta",
        "Environment :: Console",
        "Intended Audience :: Developers",
        "Intended Audience :: End Users/Desktop",
        "Intended Audience :: Science/Research",
        "License :: OSI Approved :: BSD License",
        "Natural Language :: English",
        "Operating System :: OS Independent",
        "Programming Language :: Python",
        "Topic :: Scientific/Engineering :: Information Analysis",
        "Topic :: Utilities",
    ],
    packages=["pymdknit"],
    entry_points={
        "console_scripts": ["pymdknit = pymdknit.pymdknitapp:launch_new_instance"]
    },
    install_requires=[
        "pyyaml",
    ],
)
</file>

<file path="README.md">
# THIS PROJECT IS NOT ANYMORE ACTIVE

A replacement could be [jupyter-book](https://github.com/executablebooks/jupyter-book).

# knitpy: Elegant, flexible and fast dynamic report generation with python

This is a port of knitr (http://yihui.name/knitr/) and rmarkdown
(http://rmarkdown.rstudio.com/) to python.

To start with, you can run the [example overview document](examples/knitpy_overview.pymd). To 
convert to all defined output formats, run `knitpy --to="all"  -- examples\knitpy_overview.pymd`.
This will produce a `html`, `docx` and `pdf` output (if you have `pdflatex` in path). You can 
view a [markdown rendered](examples/knitpy_overview.html_document.md) and a 
[html rendered](http://htmlpreview.github.io/?https://github.com/JanSchulz/knitpy/blob/master/examples/knitpy_overview.html)
version of this file. It's not yet as pretty as the knitr version...

For a description of the code format see http://rmarkdown.rstudio.com/ and replace
`{r <r style options>}` by `{python <python style options>}` and of course use python 
code blocks...

It uses the IPython kernel infrastructure to execute code, so all kernels for IPython 
are (aem... can potentially be) supported.

## What works:
* code blocks and inline code
* plots are shown inline
* `knitpy filename.pymd` will convert filename `filename.pymd` to the default output format `html`.
* output formats `html`, `pdf` and `docx`. Change with `--to=<format>`
* `--to=all` will convert to all export formats specified in the yaml header
* code chunk arguments `eval`, `results` (apart form "hold"), `include` and `echo`
* errors in code chunks are shown in the document
* uses the IPython display framework, so rich output for objects implementing `_repr_html_()` or 
  `_repr_markdown_()`. Mimetypes not understood by the final output format are automatically 
  converted via pandoc.
* config files: generate an empty one with `knitpy --init --profile-dir=.`
* using it from python (-> your app/ ipython notebook): 
  `import knitpy; knitpy.render(filename.pymd, output="html")` will convert `filename.pymd`
  to `filename.html`. `output=all` will convert to all document types (as specified in the 
  YAML header of the document). The call will return a list of converted documents.
* debugging with ``--debug`, `--kernel-debug=True`, `--output-debug=True`

## What does not work (=everything else :-) ):
* most YAML headers are currently ignored
* some advertised command-line options are ignored
* most code chunk arguments (apart from the ones above) are ignored
* probably lots of other stuff...

## Todo
* fix the above...
* refactor the parsing, so that it is line based
  - errors make more sense, because it knows the line ("block starting at line....")
* add some traits for the default pdflatex/pandoc executeable, so they don't have to be in path
* the final output has to configure the "includeable" markup docs
  - html in html
  - latex in html?
  - ...
* more arguments for code blocks
* more output formats? -> make output format configurable
* more unit-/outputtests...
  - codeblocks + inline
  - yaml
  - errors
  - pandoc caller (via mocks?)
* Documentation
  - what works? what is not supported?
  - differences to rmarkdown / knitr?
* implement more kernel engines (R...) and make it possible to supply/change ones 
  (for installed kernels for python2/3 or coda environments)
* implement a nice default html template
  -  Try https://github.com/timtylin/scholdoc-templates
* implement "code tidying"
  - maybe use https://github.com/google/yapf?
* use metadata in keep_md output (like rmarkdown does...
  - should output `#<title>\n<author>\n<date>` before the rest
  - remove the first yaml block, but keep everything else...
* chunk caching
</file>

</files>
